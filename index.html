<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小白拜拜拜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小白拜拜拜">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小白拜拜拜">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小白拜拜拜">
  
    <link rel="alternate" href="/atom.xml" title="小白拜拜拜" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小白拜拜拜</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面试复习（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/面试复习（3）/" class="article-date">
  <time datetime="2018-05-14T13:57:23.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/面试复习（3）/">面试复习（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-iter-与-iter"><a href="#1-iter-与-iter" class="headerlink" title="1. iter++ 与 ++iter"></a>1. iter++ 与 ++iter</h4><p>要尽量使用<code>++iter</code>而不是<code>iter++</code>，因为<code>++iter</code>前自增运算符改变了对象的状态并返回对象改变后的状态，不需要创建新的临时对象，而<code>iter++</code>需要先创建临时对象保存之前的对象状态，然后改变之前的对象状态，最后返回临时对象。示例如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNum</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	MyNum&amp; <span class="keyword">operator</span>++() <span class="comment">//++num</span></span><br><span class="line">	&#123;</span><br><span class="line">		++num;</span><br><span class="line">		<span class="keyword">return</span> * <span class="keyword">this</span>; <span class="comment">//++后直接返回自身</span></span><br><span class="line">	&#125;</span><br><span class="line">	MyNum&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) <span class="comment">//num++</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyNum tmp = * <span class="keyword">this</span>; <span class="comment">//创建了临时变量</span></span><br><span class="line">		++num;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyNum myNum;</span><br><span class="line">	myNum.num = <span class="number">3</span>;</span><br><span class="line">	MyNum tmp = myNum++;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tmp.num &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//3</span></span><br><span class="line">	MyNum tmp1 = ++myNum;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tmp1.num &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-二叉树的各种遍历方法"><a href="#2-二叉树的各种遍历方法" class="headerlink" title="2. 二叉树的各种遍历方法"></a>2. 二叉树的各种遍历方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preSortRecur</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        preSortRecur(root-&gt;left);</span><br><span class="line">        preSortRecur(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preSort</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty() || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                s.push(p-&gt;right);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node* tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midSortRecur</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        midSortRecur(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        midSortRecur(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midSort</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty() || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node* tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            p = tmp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backSortRecur</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        backSortRecur(root-&gt;left);</span><br><span class="line">        backSortRecur(root-&gt;right);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backSort</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty() || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node* tmp = s.top();</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;isFirst == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;isFirst = <span class="literal">true</span>;</span><br><span class="line">                p = tmp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; tmp-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = arr[s];</span><br><span class="line">	<span class="keyword">int</span> i = s;</span><br><span class="line">	<span class="keyword">int</span> j = s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= e)  <span class="comment">//[s + 1, i]部分均小于num,[i + 1, j]部分均大于等于num</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[j] &lt; num)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; num)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">				arr[i] = arr[j];</span><br><span class="line">				arr[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[s] = arr[i];  <span class="comment">//将num放到合适的位置。</span></span><br><span class="line">	arr[i] = num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idx = locate(s, e);</span><br><span class="line">	<span class="keyword">if</span> (s &lt; idx - <span class="number">1</span>)</span><br><span class="line">		quickSort(s, idx - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (idx + <span class="number">1</span> &lt; e)</span><br><span class="line">		quickSort(idx + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4. 堆排序"></a>4. 堆排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">formHeap</span><span class="params">(<span class="keyword">int</span> no, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[no];</span><br><span class="line">	<span class="keyword">int</span> type = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span> * no &lt;= count)  <span class="comment">//注意这里是count</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">2</span> * no] &gt; temp)</span><br><span class="line">		&#123;</span><br><span class="line">			type = <span class="number">0</span>;</span><br><span class="line">			temp = arr[<span class="number">2</span> * no];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span> * no + <span class="number">1</span> &lt;= count)  <span class="comment">//注意这里是count</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">2</span> * no + <span class="number">1</span>] &gt; temp)</span><br><span class="line">		&#123;</span><br><span class="line">			type = <span class="number">1</span>;</span><br><span class="line">			temp = arr[<span class="number">2</span> * no + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = arr[no];</span><br><span class="line">		arr[no] = arr[<span class="number">2</span> * no + type];</span><br><span class="line">		arr[<span class="number">2</span> * no + type] = temp;</span><br><span class="line">		formHeap(<span class="number">2</span> * no + type, count);  </span><br><span class="line">        <span class="comment">//发生变化后也许需要对子树进行操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i / <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			formHeap(j, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[<span class="number">1</span>];  </span><br><span class="line">		arr[<span class="number">1</span>] = arr[i];</span><br><span class="line">		arr[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/面试复习（3）/" data-id="cjhm0p198000ukpqw8uoh4y6e" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/复习/">复习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-effective-c-（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/11/effective-c-（2）/" class="article-date">
  <time datetime="2018-05-10T17:03:59.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/11/effective-c-（2）/">effective-c++（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="10-别让异常逃离析构函数"><a href="#10-别让异常逃离析构函数" class="headerlink" title="10.别让异常逃离析构函数"></a>10.别让异常逃离析构函数</h4><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不能传播）或结束程序。<br><br>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么<code>class</code>应该提供一个普通函数（而非在析构函数中）执行该操作。</p>
<h4 id="11-绝不在构造和析构过程中调用virtual函数"><a href="#11-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="11.绝不在构造和析构过程中调用virtual函数"></a>11.绝不在构造和析构过程中调用virtual函数</h4><h6 id="不要在构造函数中调用虚函数的原因"><a href="#不要在构造函数中调用虚函数的原因" class="headerlink" title="不要在构造函数中调用虚函数的原因"></a>不要在构造函数中调用虚函数的原因</h6><p>第一个原因，在概念上，构造函数的工作是为对象进行初始化。在构造函数完成之前，被构造的对象被认为“未完全生成”。当创建某个派生类的对象时，如果在它的基类的构造函数中调用虚函数，那么此时派生类的构造函数并未执行，所调用的函数可能操作还没有被初始化的成员，浙江导致灾难的发生。<br><br>第二个原因，即使想在构造函数中实现动态联编，在实现上也会遇到困难。这涉及到对象虚指针（vptr）的建立问题。在Visual C++中，包含虚函数的类对象的虚指针被安排在对象的起始地址处，并且虚函数表（vtable）的地址是由构造函数写入虚指针的。所以，一个类的构造函数在执行时，并不能保证该函数所能访问到的虚指针就是当前被构造对象最后所拥有的虚指针，因为后面派生类的构造函数会对当前被构造对象的虚指针进行重写，因此无法完成动态联编。</p>
<h6 id="不要在析构函数中调用虚函数的原因"><a href="#不要在析构函数中调用虚函数的原因" class="headerlink" title="不要在析构函数中调用虚函数的原因"></a>不要在析构函数中调用虚函数的原因</h6><p>从概念上说，析构函数是用来销毁一个对象的，在销毁一个对象时，先调用该对象所属类的析构函数，然后再调用其基类的析构函数，所以，在调用基类的析构函数时，派生类对象的“善后”工作已经完成了，这个时候再调用在派生类中定义的函数版本已经没有意义了。</p>
<h4 id="12-令operator-返回一个reference-to-this"><a href="#12-令operator-返回一个reference-to-this" class="headerlink" title="12. 令operator=返回一个reference to * this"></a>12. 令operator=返回一个reference to * this</h4><p>为了实现连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。这份协议被所有内置类型和标准程序库提供的类型如string、vector、complex等共同遵守，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    Widget &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="13-在operator-中处理“自我赋值”"><a href="#13-在operator-中处理“自我赋值”" class="headerlink" title="13. 在operator=中处理“自我赋值”"></a>13. 在operator=中处理“自我赋值”</h4><p>自我赋值发生在对象被赋值给自己时，需要确保自我赋值时<code>operator=</code>有良好的行为，其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序，以及<code>copy-and-swap</code>。实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    Bitmap* pb;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">        pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//问题出现在operator=函数中的* this和rhs可能是同一个对象，所以</span></span><br><span class="line"><span class="comment">//可能持有的指针指向了一个已经被删除的对象。解决方法可以添加一个</span></span><br><span class="line"><span class="comment">//“证同测试”：</span></span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果new Bitmap导致异常，会得到一个被删除的指针，这时可以先创建</span></span><br><span class="line"><span class="comment">//临时变量。方法如下：</span></span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb)；</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="14-复制对象时勿忘其每一个成分"><a href="#14-复制对象时勿忘其每一个成分" class="headerlink" title="14. 复制对象时勿忘其每一个成分"></a>14. 复制对象时勿忘其每一个成分</h4><p>如果声明自己的复制函数（拷贝构造或赋值函数），编译器不会缺省实现，这时很容易发生错误。<code>copy</code>函数应该确保复制对象中的所有成员变量以及所有的<code>base class</code>成分。不要尝试在某个复制函数中实现另一个复制函数，可将共同功能放入第三个函数，并由两个函数共同调用。</p>
<h4 id="15-以对象管理资源"><a href="#15-以对象管理资源" class="headerlink" title="15. 以对象管理资源"></a>15. 以对象管理资源</h4><p>首先是实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//工厂函数，返回指针，指向Investment继承体系内的动态分配对象。调用者有责任</span></span><br><span class="line"><span class="comment">//删除它。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Investment* pInv = createInvestment();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来妥当，但是有些情况可能无法正确删除，当<code>...</code>区域中存在<code>return</code>或者异常时。为了确保<code>createInvestment</code>返回的资源总是被释放，需要将资源放入对象内，当控制流离开<code>f</code>，对象的析构函数会自动释放那些资源。<br>许多资源被动态分配与<code>heap</code>内而后被用于单一区域或函数内，应该在控制流离开那个区块或函数时被释放。<code>auto_ptr</code>可以实现此功能，其析构函数自动对所指对象调用<code>delete</code>，实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">    std::auto_ptr&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应做到<strong>获取资源后立刻放进管理对象</strong>，即资源取得时机即为初始化时机。<code>Resource acquisition is initialization RALL</code>。<strong>管理对象运用析构函数确保资源被释放</strong>，不论控制流如何离开区块，一旦对象被销毁其析构函数自然会被调用，于是资源释放。<br><br>由于<code>auto_ptr</code>被销毁时会自动删除所指物，所以一定不能让多个<code>auto_ptr</code>指向同一对象，否则删除后会出现未定义。为了预防此问题，通过拷贝构造函数或赋值操作符复制后会变成<code>null</code>，而复制所得的指针将取得资源的控制权。<br><br><code>auto_ptr</code>的替代方案是<code>share_ptr</code>，引用计数型智能指针，<code>reference counting smart pointer</code>，可以持续追踪共有多少个对象指向某个资源，并在无人指向时自动删除。但是不能打破环状引用。两个智能指针在析构函数中做<code>delete</code>而不是<code>delete[]</code>，所以在数组上使用是不好的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/11/effective-c-（2）/" data-id="cjhm0p18k000ckpqwvn17blkg" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/effective-c/">effective c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-effective-c-（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/08/effective-c-（1）/" class="article-date">
  <time datetime="2018-05-08T14:04:30.000Z" itemprop="datePublished">2018-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/08/effective-c-（1）/">effective c++（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-声明式、定义式、签名式、初始化"><a href="#1-声明式、定义式、签名式、初始化" class="headerlink" title="1.声明式、定义式、签名式、初始化"></a>1.声明式、定义式、签名式、初始化</h4><h4 id="2-explicit"><a href="#2-explicit" class="headerlink" title="2.explicit"></a>2.explicit</h4><p>explicit阻止被用来执行隐式的类型转换。禁止编译器执行非预期的类型转换。</p>
<h4 id="3-C-是一个语言联邦"><a href="#3-C-是一个语言联邦" class="headerlink" title="3.C++是一个语言联邦"></a>3.C++是一个语言联邦</h4><p>起初它只是C加上一些面向对象特性，最初名称为C with Classes，后来异常对函数结构化带来不同做法，模板提供新的思考方式，STL定义了伸展性做法，C++也增加了重载操作。<br>现在C++是多重泛型编程语言，支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程模式（metaprogramming）。</p>
<h4 id="4-尽量以const、enum、inline替换预处理的-define"><a href="#4-尽量以const、enum、inline替换预处理的-define" class="headerlink" title="4.尽量以const、enum、inline替换预处理的#define"></a>4.尽量以<code>const</code>、<code>enum</code>、<code>inline</code>替换预处理的<code>#define</code></h4><p>在类中声明数组的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">array</span>[a]; <span class="comment">//要使用a则必须是静态变量，至多只有一份实体，使用静态变量必须再声明为常量。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span>&#123;a = <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">array</span>[a];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用宏可能出现很多错误，例如<code>#define max(a, b) (a) &gt; (b) ? (a) : (b)</code>，可以使用内联函数进行替换。尽量以<code>const</code>、<code>enum</code>、<code>inline</code>替换预处理的<code>#define</code>，对于单纯常量，最好以<code>const</code>对象或<code>enum</code>替换<code>#define</code>。对于形似函数的宏，最好改用<code>inline</code>函数替换<code>#define</code>。</p>
<h4 id="5-尽可能的用const"><a href="#5-尽可能的用const" class="headerlink" title="5.尽可能的用const"></a>5.尽可能的用<code>const</code></h4><p><code>const</code>可以指定语义约束，修饰指针时可分为指针常量和常量指针，STL容器是根据指针塑模出来，迭代器作用类似<code>T*</code>指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line"><span class="comment">//类似于指针常量，指针不可变，所以iter++出错。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = vec.begin();</span><br><span class="line"><span class="comment">//类似于常量指针，指针指向常量，所以*iter=10出错。</span></span><br></pre></td></tr></table></figure></p>
<p>令函数返回一个常量，往往可以降低因客户错误造成的意外，而又不至于放弃安全和高效性。当参数不需要改动的时候可以声明为<code>const</code>。<br><code>const</code>成员函数中如果只是常量性不同，可以被重载。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span>&amp; <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> text[position];&#125; <span class="comment">//operator[] for const对象</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;<span class="keyword">return</span> text[position];&#125; <span class="comment">//operator[] for non-const对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">//调用非常量operator</span></span><br><span class="line"><span class="function">TextBlock <span class="title">tbc</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tbc[<span class="number">0</span>]; <span class="comment">//调用常量operator</span></span><br></pre></td></tr></table></figure></p>
<p>常量成员函数两个流行概念，<code>bitwise constness</code>和<code>logical constness</code>， <code>bitwise constness</code>不可更改对象内任何<code>non-static</code>成员。<code>logical constness</code>可以修改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!lengthIsValid)&#123;</span><br><span class="line">			textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">			lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* pText;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">size_t</span> textLength; <span class="comment">//不添加mutable会报错</span></span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>版本调用<code>const</code>版本可以避免代码重复。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> text[position];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(   <span class="comment">//将op[]返回值的const转除</span></span><br><span class="line">			<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(* <span class="keyword">this</span>)  <span class="comment">//为*this加上const</span></span><br><span class="line">				[position]	<span class="comment">//调用const op[]</span></span><br><span class="line">			);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-确定对象被使用前已先被初始化"><a href="#6-确定对象被使用前已先被初始化" class="headerlink" title="6.确定对象被使用前已先被初始化"></a>6.确定对象被使用前已先被初始化</h4><p>通常如果使用<code>C part of C++</code>而且初始化可能招致运行期成本，那么就不保证发生初始化，一旦进入<code>non-C parts of C++</code>,规则有些变化。<br>最佳方法是对于无任何成员内置类型进行手动初始化。对于内置类型以外的责任落到构造函数身上。注意赋值和初始化的区别。写到<strong>成员初始表</strong>中才是初始化，类以声明次序进行初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; address,</span><br><span class="line">	 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">: theName(name),</span><br><span class="line">  theAddress(address),</span><br><span class="line">  thePhones(phone),</span><br><span class="line">  numTimeConsulted(<span class="number">0</span>)  <span class="comment">//成员初值列，真正的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">	theName = name;</span><br><span class="line">	theAddress = address; <span class="comment">//只是赋值，默认的构造函数进行初始化</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>C++</code>对定义在不同的编译单元内的非局部静态对象<code>(non-local static)</code>的初始化相对次序无明确定义。编译单元是指产出单一目标文件的那些源码。基本上是单一源码文件加上所包含的头文件。当某个编译单元的非局部静态对象调用了另一个编译单元的非局部静态对象时会出现错误。<code>C++</code>保证函数内的<code>local static</code>对象会在函数被调用期间、首次遇到该对象的定义式时被初始化,可以使用类似单例模式的方法,使用局部静态对象替换局部非静态对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> FileSystem fs;</span><br><span class="line">	<span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span>&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7-了解C-默默编写并调用了哪些函数"><a href="#7-了解C-默默编写并调用了哪些函数" class="headerlink" title="7.了解C++默默编写并调用了哪些函数"></a>7.了解C++默默编写并调用了哪些函数</h4><p>如果自己没有对空类进行声明，编译器会为其声明（编译器版本的）一个拷贝构造函数、析构函数、copy赋值操作符，如果没有声明构造函数也会声明一个默认构造函数。如果声明了构造函数就不会再创建默认的构造函数。c++不允许让引用该指向不同的对象，所以需要自己定义copy赋值操作符。</p>
<h4 id="8-若不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#8-若不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="8.若不想使用编译器自动生成的函数，就应该明确拒绝"></a>8.若不想使用编译器自动生成的函数，就应该明确拒绝</h4><p>有很多类的对象时独一无二的，这是不需要拷贝构造函数和copy赋值运算符，实现这一目的的方法是在类中声明但不实现并且需要设置为私有的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HomeForSale();</span><br><span class="line">	~HomeForSale();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HomeForSale(<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">	HomeForSale&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是如果在member函数或友元中访问，会出现链接错误，将连接期错误移至编译期是有可能的，只要将copy构造函数和copy assignment操作符声明为private就可以办到，但是在一个基类中。</p>
<h4 id="9-为多态基类声明virtual析构函数"><a href="#9-为多态基类声明virtual析构函数" class="headerlink" title="9.为多态基类声明virtual析构函数"></a>9.为多态基类声明virtual析构函数</h4><p>多态性质的基类应该声明一个<code>virtual</code>析构函数，如果<code>class</code>带有任何<code>virtual</code>函数，它就应该拥有一个<code>virtual</code>析构函数。如果类的设计不是为了基类所用，就不应该声明为<code>virtual</code>析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Shape()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"shape create"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~Shape() <span class="comment">//声明为virtual时，基类和子类的构造函数</span></span><br><span class="line">    <span class="comment">//和析构函数分别调用，否则，析构函数只有基类会调用</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"shape delete"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getSquare</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Rect(<span class="keyword">double</span> width, <span class="keyword">double</span> height)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"rect create"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;width = width;</span><br><span class="line">		<span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">	&#125;</span><br><span class="line">	~Rect()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"rect delete"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getSquare</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> width * height;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> width, height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Shape* <span class="title">getShape</span><span class="params">(<span class="keyword">char</span>* type)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Shape * shape = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">"Rect"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			shape = <span class="keyword">new</span> Rect(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> shape;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Shape * rect = Factory::getShape(<span class="string">"Rect"</span>);</span><br><span class="line">	<span class="keyword">if</span> (rect != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; rect-&gt;getSquare() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> rect;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>欲实现virtual函数，对象需要携带某些信息，主要用来在运行期决定哪个virtual函数需要被调用。这份信息通常是由一个vptr虚函数表指针指出，它指向一个由函数指针构成的数组，成为vtble(虚函数表)。每一个带有virtual函数的类都有一个相应的vtbl。当对象调用某个虚函数时，实际被调用的函数取决于该对象的vptr所指的那个vtbl。-编译器会在其中寻找到合适的函数指针。如果类中包含virtual函数，对象的体积会增加。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/08/effective-c-（1）/" data-id="cjhm0p18f000akpqwamezl99y" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/effective-c/">effective c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/01/网络（3）/" class="article-date">
  <time datetime="2018-05-01T11:55:20.000Z" itemprop="datePublished">2018-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/01/网络（3）/">网络（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h4><p><code>TCP: Transmission control protocal</code>，传输控制协议，是与<code>UDP</code>并列的两个传输协议。</p>
<h5 id="C-S设计模式"><a href="#C-S设计模式" class="headerlink" title="C/S设计模式"></a>C/S设计模式</h5><p><code>TCP</code>的设计模式成为<code>C/S</code>，即<code>Client-Server</code>（客户机-服务器）模式（<code>UDP</code>两端是对等的，<code>TCP</code>两端是不对等的，一端称为<code>Client</code>，另一端称为<code>Server</code>）。<br>对于<code>TCP</code>，客户端和服务器的写法是不同的。</p>
<ol>
<li>客户端<ol>
<li>连接服务器<code>connect</code>。</li>
<li>通讯</li>
</ol>
</li>
<li>服务器<ol>
<li>主<code>socket</code>接收连接<code>Accept</code>。</li>
<li>有连接到来时，创建一个<code>Working Socket</code>为<code>Client Socket</code>提供服务。每一个<code>Client</code>都分配一个<code>Socket</code>，专门的一对一的提供服务。</li>
</ol>
</li>
</ol>
<p>例如：银行服务热线<code>95555</code>，一个客户（<code>Client Socket</code>）拿起电话拨打服务<code>95555</code>，<code>connect(95555)</code>。接通（<code>connected</code>），你的电话转接到一个工作人员（<code>Working Socket</code>）。<br><code>TCP</code>中应该使用多线程技术。</p>
<h6 id="服务器："><a href="#服务器：" class="headerlink" title="服务器："></a>服务器：</h6><ol>
<li><code>serv_sock.Open(OS_SockAddr(9555), true);</code></li>
<li><code>serv_sock.Listen();</code></li>
<li><code>serv_sock.Accept(&amp;work_set);</code></li>
</ol>
<h6 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h6><ol>
<li><code>Open(), Connect()</code></li>
<li><code>Send/Recv</code></li>
</ol>
<p>代码实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">OS_TcpSocket client;</span><br><span class="line">client.Open();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n = client.Connect(peer);</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection fail!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[maxLen];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//gets(buf);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    client.Send(buf, len);</span><br><span class="line">    len = client.Recv(buf, maxLen);</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">client.Close();</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端，使用了多线程，每次监听到一个连接就新建一个线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work_thread</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Work_thread(OS_TcpSocket work_sock)</span><br><span class="line">	&#123;</span><br><span class="line">		maxLen = <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;work_sock = work_sock;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	OS_TcpSocket work_sock;</span><br><span class="line">	<span class="keyword">int</span> maxLen;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[maxLen];</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> n = work_sock.Recv(buf, maxLen);</span><br><span class="line">			<span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			buf[n] = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">strcpy</span>(buf, <span class="string">"ok!"</span>);</span><br><span class="line">			<span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">			work_sock.Send(buf, len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OS_TcpSocket server;</span><br><span class="line">server.Open(OS_SockAddr(<span class="number">8888</span>), <span class="literal">true</span>);</span><br><span class="line">server.Listen();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"服务器启动"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    OS_TcpSocket work_set;</span><br><span class="line">    <span class="keyword">int</span> status = server.Accept(&amp;work_set);</span><br><span class="line">    <span class="keyword">if</span>(status &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Work_thread* conn = <span class="keyword">new</span> Work_thread(work_set);</span><br><span class="line">    conn-&gt;Run();</span><br><span class="line">    <span class="comment">//Work_thread conn(work_set); conn.Run(); 这样会报错，还不清楚原因</span></span><br><span class="line">&#125;</span><br><span class="line">server.Close();</span><br></pre></td></tr></table></figure></p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>请求应答模式，一般情况下，需要客户端发起一个请求，然后服务器做出针对性的应答。</li>
<li>服务器应该处于常开状态，服务器应该保持一直运行，随时等到客户端发送请求。</li>
<li><code>Send/Recv</code>不需要再指定目标地址，因为在<code>Connect</code>成功之后，<code>Client</code>和服务器的某个<code>Working Socket</code>已经配对，是一对一的进行通话。</li>
<li>服务器一般只需要指定端口号。<code>OS_SockAddr(9555)</code>相当于<code>OS_SockAddr(&quot;0000&quot;</code> <code>, 9555)</code>。</li>
</ol>
<h4 id="TCP内部缓冲区"><a href="#TCP内部缓冲区" class="headerlink" title="TCP内部缓冲区"></a>TCP内部缓冲区</h4><p><code>UDP Socket</code>的缓冲区：包式存取，每个包带地址。<br><code>TCP Socket</code>的缓冲区：流式存取，每个包不带地址。分界是自由的。例如两次发送<code>&quot;hello&quot;</code>和<code>&quot;world&quot;</code>，服务可能一次就输出了<code>helloworld</code>。</p>
<h5 id="定义边界"><a href="#定义边界" class="headerlink" title="定义边界"></a>定义边界</h5><p>设计交互协议时，要自己定义消息的边界。<code>a-&gt;b(请求) a&lt;-b(应答) a-&gt;b(请求) a&lt;-b(应答)</code>，有两种方法：</p>
<ol>
<li>先发长度，后发数据<code>00 05 &#39;h&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39;</code></li>
<li>每段消息加上结束符(结束符不属于正文)，<code>hello\r\n</code><br>主要代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">buf = getBuf(work_sock, <span class="number">2</span>);  <span class="comment">//获取数据长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> num = cTos(buf);</span><br><span class="line">buf = getBuf(work_sock, num); <span class="comment">//根据长度获取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">getBuf</span><span class="params">(OS_TcpSocket sock, <span class="keyword">unsigned</span> <span class="keyword">short</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[num];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(count &lt; num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = sock.Recv(buf + count, num - count);</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		count += n;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[num] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><ol>
<li><code>Send</code>阻塞：当<code>SendBuf</code>满时。</li>
<li><code>Recv</code>阻塞：当<code>RecvBuf</code>满时。<br><code>Socket</code>默认是阻塞方式，也可以手工设置为非阻塞方式。</li>
</ol>
<h5 id="设置获取缓冲区"><a href="#设置获取缓冲区" class="headerlink" title="设置获取缓冲区"></a>设置获取缓冲区</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取sendbuf大小</span></span><br><span class="line"><span class="keyword">int</span> bufsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ret = getsockopt(client_sock.hSock, SOL_SOCKET,</span><br><span class="line">        SO_SNDBUF, <span class="comment">//SO_RCVBUF</span></span><br><span class="line">        (<span class="keyword">char</span>*)&amp;bufsize, &amp;len);</span><br><span class="line"><span class="comment">//设置sendbuf大小</span></span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> ret = setsocketopt(client_sock.hSock, SOL_SOCKET,</span><br><span class="line">        SO_SNDBUF,</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;bufsize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<h4 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h4><p>交换机职责：交换数据，将从一个口进入的数据包（包括源地址和目标地址），转发到其他的口。如何转发完全由交换机决定。一种情况是直接将数据包转发到每一个口，另一种情况是交换机上记录了每个口的主机<code>IP</code>，选择对应的口转发。使用<code>wireshark</code>可以发现网口上接收到的数据包，有的目标<code>IP</code>不是自己这台主机的。</p>
<ol>
<li>发送：<code>OS</code>把数据包通过网卡、上行传至交换机。</li>
<li>接收：<code>OS</code>从网卡获取数据包。</li>
</ol>
<h5 id="UDP传输"><a href="#UDP传输" class="headerlink" title="UDP传输"></a>UDP传输</h5><p>正常流程</p>
<ol>
<li>主机<code>A</code>发送一个<code>UDP</code>包，此包抵达交换机的<code>1</code>口。</li>
<li>交换机没有干预，此包复制到<code>2、3、4</code>口。</li>
<li>处于<code>2</code>口的主机<code>B</code>，接收到这个包。<br>不正常情况<br>交换机丢到了这个包。没有转到<code>2</code>口。问题是主机<code>A</code>无法知道这个包是否抵达目标主机。</li>
</ol>
<h5 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h5><p>三次握手和四次握手。<br><img src="/images/tcp.jpg" alt=""></p>
<p><code>TCP</code>称为可靠地传输协议，因为发送端能够知道这个包有没有抵达目标，并且底层有重发机制。<code>UDP</code>的<code>SendTo</code>不会失败，它只是把数据包送出去，不管到达与否。<code>TCP</code>的<code>Send</code>包会失败，当网络不可抵达时（未收到<code>ACK</code>），就是发送失败了。</p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p><code>select</code>查询机制，本质是一个函数，用来向<code>OS</code>查询：在一堆<code>socket</code>中，查出可以读写的<code>socket</code>。<code>OS_Socket</code>类做了一个简单的封装。不能读因为缓冲区是空的，不能写因为缓冲区是满的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int Select_ForReading(int timeout);</span><br><span class="line">int Select_ForWriting(int timeout);</span><br></pre></td></tr></table></figure></p>
<p>用途：如果服务器同时与大量的客户端交互，可以用<code>select</code>查询哪些<code>socket</code>有上行的数据，如果有数据才做响应。这样就没有必要为每个<code>client</code>创建单独的一个线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/01/网络（3）/" data-id="cjhm0p192000okpqwuf1mfryi" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/30/网络（2）/" class="article-date">
  <time datetime="2018-04-30T04:13:32.000Z" itemprop="datePublished">2018-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/30/网络（2）/">网络（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><h5 id="按照字节传输"><a href="#按照字节传输" class="headerlink" title="按照字节传输"></a>按照字节传输</h5><p>网络上的数据是一个字节一个字节串行传递的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"hello"</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">5</span>, ...)</span><br></pre></td></tr></table></figure></p>
<p>那么在信道中依次传输5个字节：<code>68 65 6c 6c 6f</code>。</p>
<h5 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h5><p>当观察到一个<code>unsigned int</code>型变量的内存,<code>unsigned int a = 0x12345678;</code><br>在内存中的排列为<code>78 56 34 12</code>，却不是<code>12 34 56 78</code>，原因是因为这是一种规定。<br>小端：低位字节在内存的低地址端，高位字节在内存的高地址端。主流系统都是小端的（<code>intel/amd</code>）<br>大端：低位字节在内存的高地址端，高位字节在内存的低地址端。</p>
<h5 id="网络传输字节序"><a href="#网络传输字节序" class="headerlink" title="网络传输字节序"></a>网络传输字节序</h5><p>网络传输的时候，惯例是按照大端传输的。即把接收到的第一个字节当做高位字节看待，这就要求发送端发送的第一个字节是高位字节，而在发送端发送数据时，发送的第一个字节应该是数值在内存中的起始地址对应的那个字节（即高位字节存放在低地址），将小端转换为大端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itob_32be</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bytes[<span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    bytes[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    bytes[<span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    bytes[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h4><h5 id="默认分配端口号"><a href="#默认分配端口号" class="headerlink" title="默认分配端口号"></a>默认分配端口号</h5><p>发送方<code>Socket</code>可以不显式的指定端口号：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UdpSocket sock;</span><br><span class="line">sock.open(); <span class="comment">//不带地址</span></span><br><span class="line">sock.SendTo(); <span class="comment">//发送数据</span></span><br></pre></td></tr></table></figure></p>
<p><code>SendTo</code>函数被调用时，<code>OS</code>发现这个<code>Socket</code>还没有分配端口号，于是立即为其自动分配一个端口号，然后进行发送，接收方必须指定端口号的，发送方自动分配的端口号有一个区间，一般在<code>10000</code>以上。可以通过以下方式查看：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_SockAddr local;</span><br><span class="line">sock.GetLocalAddr(local);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port = local.GetPort();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"local port: %d \n"</span>, port);</span><br><span class="line"><span class="comment">//在发送数据时，才会自动分配端口</span></span><br></pre></td></tr></table></figure></p>
<h5 id="端口的占用"><a href="#端口的占用" class="headerlink" title="端口的占用"></a>端口的占用</h5><p>当一个<code>Socket</code>使用了某个端口，那么直到这个<code>Socket</code>被关闭，这个端口都处于被占用的状态。如果还想创建一个<code>Socket</code>，并且使用相同的端口，则创建失败。<code>sock.open()</code>返回-1。所以将端口号设置为可重用的。<code>sock.open</code>第二个参数即是能否重用的选项（内部间接调用了<code>SetOpt_ReuseAddr</code>这个函数）。一般要设置为<code>true</code>，因为有时候程序会意外关闭，即时重新启动当操作系统还没有释放这个端口时，会出现错误。</p>
<h5 id="多个发送方，一个接收方"><a href="#多个发送方，一个接收方" class="headerlink" title="多个发送方，一个接收方"></a>多个发送方，一个接收方</h5><p>接收方可以区分一个消息是谁发送的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">OS_SockAddr peer;</span><br><span class="line"><span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br></pre></td></tr></table></figure></p>
<p><code>RecvFrom</code>只是从“接受缓冲区”里取出一个数据包，这个数据包本身是带有源地址的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> peer_ip = peer.GetIp_str();</span><br><span class="line"><span class="keyword">int</span> peer_port = peer.GetPort();</span><br></pre></td></tr></table></figure></p>
<h5 id="阻塞与超时"><a href="#阻塞与超时" class="headerlink" title="阻塞与超时"></a>阻塞与超时</h5><h6 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h6><p>接收方<code>sock.RecvFrom</code>：</p>
<ol>
<li>如果<code>RecvBuf</code>中有数据，则函数立即返回。</li>
<li>如果没有数据，则函数会一直等待，知道有数据时才取出数据，这个等待行为就是“阻塞”方式，可以设置最大等待时间，超过后如果仍然没有数据，函数返回-1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.SetOpt_RecvTimeOut(<span class="number">3000</span>) <span class="comment">//超过3s仍无数据，则RecvFrom返回-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h6><p>不管有没有数据，函数都立即返回，如果有数据，则返回值<code>&gt;0</code>，如果没有数据，则返回值为<code>-1</code>。此时，需要程序定时的去调用<code>RecvFrom</code>函数去查看有没有数据，这种设计模式叫做“轮询”。</p>
<h4 id="双工通讯"><a href="#双工通讯" class="headerlink" title="双工通讯"></a>双工通讯</h4><p><strong>单工</strong>：单向通信，A只能发信号，B只能接收信号，通信是单向的。（广播、电视）<br><strong>半双工</strong>： 双向通信但是不能同时进行，A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。（要么上行（上传），要么下行（下载），比如对讲机）<br><strong>全双工</strong>：双向通信互不影响，A给B发信号的同时，B也可以给A发信号。（上行下行可同时进行，手机、电话）<br><code>UDP</code>是双工的。可以使用多线程的方式实现全双工操作，一个线程负责读，另一个线程负责写。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        OS_UdpSocket sock;</span><br><span class="line">        sock.Open();</span><br><span class="line">        <span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            sock.SendTo(buf, len, peer);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.Close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recv</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        OS_UdpSocket sock;</span><br><span class="line">        sock.Open(OS_SockAddr(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>), ture);</span><br><span class="line">        OS_SockAddr peer;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buf[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.Close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>协议，<code>protocal</code>，协议就是规定，是通信双方事先协商好的规则。它规定了数据的格式。没有协议，就无法实现数据的传输（对方读不懂）。<br>当要传递一个整数<code>0x12345678</code>给对方时，可以有多种方式。</p>
<ol>
<li>大端，按字节，<code>12 34 56 78</code>。</li>
<li>小端，按字节，<code>78 56 34 12</code>。</li>
<li>文本，十六进制， “<code>12345678</code>“（共八个字节）。</li>
<li>文本, 十进制，”<code>305419896</code>“（共九个字节）。<br>双方协商好按格式1进行传输，这便是协议。</li>
</ol>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>通过<code>UDP</code>传输，A发送B一个文件，协议如下：</p>
<ol>
<li>把文件分块传输，每块最大1024个字节。</li>
<li>数据包格式，前16字节表示指令<br> 01 开始传送 02 数据包 FF 结束传送</li>
</ol>
<p>主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open();</span><br><span class="line">File *fp = fopen(<span class="string">"123.tar"</span>, <span class="string">"rb"</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_SockAddr local;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"please input enter: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">getchar();</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">16</span>, peer);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = fread(buf + <span class="number">16</span>, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">    sock.SendTo(buf, n + <span class="number">16</span>, peer);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"send data packet, count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">16</span>, peer);</span><br><span class="line">sock.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open(local, <span class="literal">true</span>);</span><br><span class="line">OS_SockAddr peer;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">1024</span> + <span class="number">16</span>];</span><br><span class="line">FILE* fp = fopen(<span class="string">"456.tar"</span>, <span class="string">"wb"</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">1024</span> + <span class="number">16</span>; peer);</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0x01</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection start"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0xFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection end"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(buf + <span class="number">16</span>, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"receive packet, count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="强化协议，减少丢包不怕丢包"><a href="#强化协议，减少丢包不怕丢包" class="headerlink" title="强化协议，减少丢包不怕丢包"></a>强化协议，减少丢包不怕丢包</h5><ol>
<li>A控制发送节奏，不要太快。使用线程的<code>sleep</code>函数。</li>
<li>确定应答模式，接收到应答后才发下一个包。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/30/网络（2）/" data-id="cjhm0p18z000mkpqw3fc0nv7x" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/网络（1）/" class="article-date">
  <time datetime="2018-04-27T14:21:22.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/网络（1）/">网络（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h4><h5 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h5><ol>
<li>主机： <code>Host</code>,包含台式机、笔记本、手机等设备。</li>
<li>网络： <code>Internet</code></li>
<li>网络介质：<code>Media</code>：网线，光纤，无线网域网<code>wifi</code>，移动<code>3G</code>网络。</li>
<li>数据：<code>Data</code>，一串字节。</li>
</ol>
<h5 id="网络通讯观测"><a href="#网络通讯观测" class="headerlink" title="网络通讯观测"></a>网络通讯观测</h5><p><code>wireshark</code>，“抓包”工具，抓，<code>capture</code>。包，<code>packet</code>,数据包。</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p><code>Internet protocol Address</code>，网络协议地址，用于标识网络上的一台主机。<br>通常采用4字节表示，称为<code>IPv4</code>。用字符串表示时，采用10进制，以点号分开：<br><code>&quot;192.168.1.1&quot;</code>（家庭路由器地址）、<code>&quot;123.57.248.214&quot;</code>,用16进制表示<code>C0 A8 01 01</code>、<code>7B 39 F8 D6</code>。</p>
<h5 id="ping：检测连通"><a href="#ping：检测连通" class="headerlink" title="ping：检测连通"></a>ping：检测连通</h5><p><code>windows/linux</code>下都有<code>ping</code>命令，它可以检查对方的主机是否能够连通。<code>ping 123.27.148.124</code>。如果能连通说明对方主机在线，否则请求超时有三种可能性：</p>
<ol>
<li>对方关机、离线</li>
<li>己方没有连网。</li>
<li>对方在线，但是屏蔽了<code>PING</code>服务。</li>
</ol>
<h5 id="查看自己的ip地址"><a href="#查看自己的ip地址" class="headerlink" title="查看自己的ip地址"></a>查看自己的ip地址</h5><p><code>windows: ipcofig linux: ifconfig</code></p>
<h4 id="Socket复用技术"><a href="#Socket复用技术" class="headerlink" title="Socket复用技术"></a>Socket复用技术</h4><h5 id="Socket概念"><a href="#Socket概念" class="headerlink" title="Socket概念"></a>Socket概念</h5><p>两台主机进行通讯，运行不同的程序，它们都在使用网络进行数据的传输。<br>为什么一台主机上的多个程序可以同时使用网络？引入<code>Socket</code>概念，原意为“插座”，形象的表示用一根线连接两个插座，即形成一个数据通道。每个插口可以用一个数字标识（<code>0~65535</code>），这个数字就称为端口（<code>Port</code>）。<br>两个程序要进行通讯，就要各自选择一个插口，然后连接起来。<br>程序1：在<code>192.168.1.100</code>上运行，使用端口<code>9001</code>。<br>程序2：在<code>192.168.1.101</code>上运行，使用端口<code>9002</code>。<br>连接上来，就形成了一个数据通道，它们俩之间可以交流数据了（只是逻辑上的通道）。</p>
<h5 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h5><p>在多个<code>socket</code>,每个<code>socket</code>上同时传输着不同的数据（视频、文件、网页下载等）。但是网线只有一根，字节是串行传输的，如何保证正确性？<br>可以采用<strong>封包</strong>的方法，将(<code>IP,Port</code>)放在包头。这种在一个信道中，交叉间隔的传输数据的方案，叫做“分时复用”。<code>Mux</code>，重复利用的意思。</p>
<ol>
<li>发送方：复用<code>Mux</code><br>将每个<code>Socket</code>上的数据，拆分成固定格式的小包，每个小包前面加上<code>IP/Port</code>，按照时间间隔，轮番发送到信道中。</li>
<li>接收方：解复用<code>Demux</code><br>从信道中接收小包，根据包头里的Port，将小包还原成原始数据，再分发给不同的<code>Socket</code>处理。</li>
</ol>
<h6 id="大包拆分成小包"><a href="#大包拆分成小包" class="headerlink" title="大包拆分成小包"></a>大包拆分成小包</h6><p>一边拆一边合。每个包的包头加上一些标识。分包的目的是各个Socket均匀占用网络。</p>
<h4 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h4><p><code>UDP</code>: <code>User Datagram Protocol</code>，用户数据报文协议。适用于局域网的主机间通信。两台主机上的程序，在知道了对方的<code>Socket</code>地址之后，就可以适用<code>UDP</code>传输数据。<br> 发送方：<code>UdpSocket sock; sock.sendTo(...)</code>。<br> 接收方：<code>UdpSocket sock; sock.RecvFrom(...)</code>。<br> 主要代码如下所示：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//发送方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)</span></span>; <span class="comment">//ip和端口号</span></span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open(local, <span class="literal">true</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"发送方: port 9000"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    sock.SendTo(buf, len, peer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.open(local, <span class="literal">true</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="number">0</span>; <span class="comment">//终止符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Got: "</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"bye"</span>, buf) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock.Close();</span><br></pre></td></tr></table></figure></p>
<h5 id="单机测试"><a href="#单机测试" class="headerlink" title="单机测试"></a>单机测试</h5><p>正常情况下，<code>Socket</code>编程的目的是为了将数据传送到另一台主机，因此需要两台主机才可以完成测试。例如<code>192.168.1.100 -&gt; 192.168.1.101</code>。当没有多主机环境时，可以使用单机测试，目标地址为<code>127.0.0.1</code>，表示本机。当指定发送目标为<code>127.0.0.1</code>时，发送的数据不经过网卡，直接在系统内回环送回。又称为<code>loopback</code>地址（回环地址）。<code>wireshark</code>无法监测<code>loopback</code>上的数据，因为根本没有通过网卡传送。</p>
<h5 id="多机测试"><a href="#多机测试" class="headerlink" title="多机测试"></a>多机测试</h5><p>局域网下的多机测试，可以在一台交换机上插上两台主机，构建一个局域网，然后两台主机间可以通讯。如果没有两台主机，可以使用虚拟机构建多机测试环境。保证在同一个网段，将<code>ip</code>地址与子网掩码做与运算（默认<code>255.255.255.0</code>），如果相同则在同一个网段。<code>wireshark</code>中有实现过滤和事后过滤。</p>
<h4 id="内部缓冲区"><a href="#内部缓冲区" class="headerlink" title="内部缓冲区"></a>内部缓冲区</h4><p><code>SendTo()</code>和<code>RecvFrom()</code>是由系统来完成的。那么</p>
<ol>
<li>在调用<code>SendTo</code>的时候，系统是立即发送的么？</li>
<li>在调用<code>RecvFrom</code>的时候，系统是接到命令再去接收的么？<br>在系统内部，每个<code>Socket</code>关联了两个缓冲区(<code>Buffer</code>)，一个用于发送，一个用于接收。缓冲区实际上就是一片内存，用于暂时存储数据。</li>
</ol>
<h5 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h5><ol>
<li><code>SendTo</code>把数据放在<code>SendBuf</code>里，通知<code>OS</code>来取。</li>
<li><code>OS</code>在适当的时候过来取数据，并发送到网络。<br>这意味着存入数据和发送数据存在着时间差，如果数据存入太快太多，发送缓冲区可能会满。</li>
</ol>
<h5 id="接收过程"><a href="#接收过程" class="headerlink" title="接收过程"></a>接收过程</h5><ol>
<li><code>OS</code>不停把从网络上接收的数据存储到<code>RecvBuf</code>里。</li>
<li><code>RecvFrom</code>从缓冲区中取数据。<br>这意味着不论是否去取数据，<code>OS</code>总是默默的把数据先接收下来存储好，<code>RecvFrom</code>是从<code>RecvBuf</code>里取走现成的数据。如果不及时取走，则缓冲区可能会满。</li>
</ol>
<p>发送和接收是一个异步过程，发送的时候，先把数据放入缓冲区中，然后由<code>OS</code>安排发送，接收的时候，由<code>OS</code>先接收下来存在缓冲区，而<code>RecvFrom</code>只是从缓冲区取走现成的数据。</p>
<h5 id="“缓冲区满”的处理"><a href="#“缓冲区满”的处理" class="headerlink" title="“缓冲区满”的处理"></a>“缓冲区满”的处理</h5><h6 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h6><ol>
<li>直到缓冲区有剩余空间（阻塞）。</li>
<li>新发送的数据没有存入缓冲区。</li>
</ol>
<h6 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h6><ol>
<li>新的数据不被接收。</li>
<li>删除缓冲区里的现有数据，存放新的数据<br>1和2都会引起丢包现象</li>
</ol>
<h6 id="设置发送-接收缓冲区的大小"><a href="#设置发送-接收缓冲区的大小" class="headerlink" title="设置发送/接收缓冲区的大小"></a>设置发送/接收缓冲区的大小</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setsocketopt(sock.hSock, SOL_SOCKET, <span class="comment">//opt即为option</span></span><br><span class="line">    SO_SENBUF, <span class="comment">//代表sendBuf，SO_RCVBUF代表recvBuf</span></span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;bufsize,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">int</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>设置成功与否由操作系统决定。</p>
<h6 id="丢包问题"><a href="#丢包问题" class="headerlink" title="丢包问题"></a>丢包问题</h6><p>一般情况下，设置缓冲区的大小并不能解决“丢包”问题。<br>要注意一下三个方面：</p>
<ol>
<li>发送是否均匀。</li>
<li>接收是否及时。</li>
<li>接收带宽是否超过实际传输带宽。发送数据量过大会丢包。视频包可能会出现。<br>另外，即使<code>HostA</code>和<code>HostB</code>处理的都没有问题，网络上的任意一个中间节点设备都有可能丢包。丢包问题对于<code>USP</code>来说是很常见的，再设计是就要考虑到这一点，再决定使用<code>UDP</code>的时候就应该允许丢包，要做的是尽量的减少丢包。</li>
</ol>
<h6 id="适合UDP传输的情况"><a href="#适合UDP传输的情况" class="headerlink" title="适合UDP传输的情况"></a>适合UDP传输的情况</h6><p>允许丢包的场合，比如每秒钟把设备的实时数据发送给管理主机，在管理主机的界面上显示。这种情况即使丢了一次包，也没有太大关系，下次会继续发送的。但是当传输压缩文件*.rar，如果丢了一个包，整个文件就损坏了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/网络（1）/" data-id="cjhm0p18y000kkpqwz9jw1edl" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/线程（3）/" class="article-date">
  <time datetime="2018-04-27T09:04:21.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/线程（3）/">线程（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="线程间的通信机制-信号量"><a href="#线程间的通信机制-信号量" class="headerlink" title="线程间的通信机制-信号量"></a>线程间的通信机制-信号量</h4><h5 id="引例（生产者消费者问题）"><a href="#引例（生产者消费者问题）" class="headerlink" title="引例（生产者消费者问题）"></a>引例（生产者消费者问题）</h5><p><code>Producer</code>: 生产者，每个几秒生成一个物品，并放入缓冲区中。<br><code>Consumer</code>: 消费者，一旦发现缓冲区里有物品即可取走。<br>一个读一个写。<br>如何能保证即时取走？</p>
<h6 id="轮询机制"><a href="#轮询机制" class="headerlink" title="轮询机制"></a>轮询机制</h6><p><code>Consumer</code>线程不知道何时有物品可以取，只是不停地去查询（比如每隔<code>50ms</code>查询一次，以便及时取走）轮询的间隔不能太大，否则缓冲区可能已经堆积如山了。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">OS_Mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">int</span> r = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"放入物品："</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            Msleep(r * <span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"取出物品："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            Msleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上段代码中，生产者和消费者之间是没有联系的，不能保证真正及时的取出来，查询不能太频繁（浪费<code>CPU</code>），不频繁的时候（缓存区满），难以把握，需要设计一个合理的轮询间隔。最好有一个通知机制：生产者把物品放进去之后，通知消费者，消费者接到通知后，再去取物品。这就出现了信号量机制。</p>
<h6 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h6><p>信号量：<code>Semaphore</code>,用于实现线程间的通知机制（和<code>Mutex</code>一样，是一个系统级对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_Semaphore g_sem;</span><br><span class="line">第一个线程: Producer</span><br><span class="line">    g_sem.Post(); //通知</span><br><span class="line">第二个线程: Consumer</span><br><span class="line">    g_sem.Wait(); //等待通知</span><br></pre></td></tr></table></figure></p>
<p><code>osapi</code>库的源代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Semaphore::Init(<span class="keyword">int</span> initial_value)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = <span class="keyword">new</span> OS_Semaphore_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    m_Priv = priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;priv-&gt;hSem, <span class="number">1</span>, initial_value) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> OS_Semaphore::wait()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;priv-&gt;hsem) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OS_Semaphore::Post()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span>;</span><br><span class="line">    sem_post(&amp;priv-&gt;hSem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>信号量的值： <code>0, 1, 2, ..., N, ...</code><br>生产者可以一次放入多个物品，并将信号量的值增加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_sem.Post();//信号量的值加1</span><br><span class="line">g_sem.Wait();//信号量的值减1。如果信号量的值为0，则线程进入等待状态（阻塞），此时不占用cpu。</span><br></pre></td></tr></table></figure></p>
<p>使用信号量机制的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="function">OS_Semaphore <span class="title">g_sem</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//将初始信号量设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">int</span> r = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"放入物品："</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            g_sem.Post();</span><br><span class="line">            Msleep(r * <span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            g_sem.Wait();</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"取出物品："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据实际情况，将信号量的值初始化为<code>0</code>或其他正数，一般情况信号量的初始值由你的实现应用中对应的那个量决定，比如，缓冲区中的物品数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OS_Semaphore g_sem(0);</span><br><span class="line">OS_Semaphore g_sem(10); //已经有了10个量</span><br></pre></td></tr></table></figure></p>
<h6 id="超时等待机制"><a href="#超时等待机制" class="headerlink" title="超时等待机制"></a>超时等待机制</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = g_sem.Wait(<span class="number">1000</span>); <span class="comment">//ms</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="comment">//如果返回值不为0，表明已经超时</span></span><br><span class="line">&#123;<span class="comment">//超时处理&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>osapi</code>中超时处理的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Semaphore::Wait(<span class="keyword">int</span> ms)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    timeval tv_now;</span><br><span class="line">    gettimeofday(&amp;tv_now, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    timespec ts;</span><br><span class="line">    ts.tv_sec = tv_now.tv_sec;</span><br><span class="line">    ts.tv_nsec = tv_now.tv_usec * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ns = ts.tv_nsec + (ms % <span class="number">1000</span>)  * <span class="number">1000000</span>;</span><br><span class="line">    ts.tv_nsec = ns % <span class="number">1000000000</span>;</span><br><span class="line">    ts.tv_sec += ns / <span class="number">1000000000</span>;</span><br><span class="line">    ts.tv_sec += ms / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_timedwait(&amp;priv-&gt;hSem, &amp;ts) != <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/线程（3）/" data-id="cjhm0p18w000ikpqw2n4lnfa5" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/线程（2）/" class="article-date">
  <time datetime="2018-04-27T07:07:47.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/线程（2）/">线程（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h4><p>多个线程间可以共享数据：</p>
<ol>
<li>全局对象</li>
<li>堆对象（动态创建的数据）<br>全局对象和堆对象的生命期足够长。</li>
</ol>
<h4 id="数据的完整性"><a href="#数据的完整性" class="headerlink" title="数据的完整性"></a>数据的完整性</h4><p>当一个线程在写，另一个线程在读，由于线程的调度由操作系统进行切换，可能数据处理操作未完成就被切换，所以这时可能会出现问题。数据不完整的根本原因是线程运行时可能会在任意时刻、任意位置被切换。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>当多个线程同时访问一块内存，就有可能会出现数据不完整的问题。此时，需要一种机制来“同步”各个线程对它的访问。（所谓同步，是指协调、安排，使之步调一致）。这种机制就是“互斥锁”机制。在<code>C++`</code>里称为<code>Mutex</code>，<code>Java</code>里称为<code>Lock</code>。</p>
<h6 id="互斥锁的使用"><a href="#互斥锁的使用" class="headerlink" title="互斥锁的使用"></a>互斥锁的使用</h6><p>在访问共享数据之前，先获取锁，在访问完毕后再释放锁。在一个线程获取锁之后，另一个线程的<code>Lock</code>操作会一直等待（阻塞），直到该锁被释放（<code>unlocked</code>）。</p>
<h6 id="互斥锁的使用模式"><a href="#互斥锁的使用模式" class="headerlink" title="互斥锁的使用模式"></a>互斥锁的使用模式</h6><ol>
<li><p>在osapi创建全局对象或堆对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">char</span> g_data[<span class="number">128</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在线程中要访问<code>g_data</code>，必须先获取锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g_mutex.Lock(); <span class="comment">//此函数会阻塞，一直等待拥有锁</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) g_data[i] = i;</span><br><span class="line">g_mutex.Unlock(); <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在<code>osapi</code>中，Lock函数和Unlock函数的相关代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Mutex::Lock()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Mutex_Priv* priv = (OS_Mutex_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_lock(&amp;priv-&gt;hMutex) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">01</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> OS_Mutex::Unlock()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Mutex_Priv* priv = (OS_Mutex_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;priv-&gt;hMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>锁机制是操作系统提供的资源，实际上是操作系统锁对象的封装。</p>
<h6 id="互斥锁的使用原则"><a href="#互斥锁的使用原则" class="headerlink" title="互斥锁的使用原则"></a>互斥锁的使用原则</h6><p>当一个线程占有锁时，应该尽快地完成对共享数据的访问。因为别的线程正在等待。一般策略是直接把数据拷贝一份然后再做处理（处理时间一般比拷贝时间更长）。<br>实例：提供一个<code>generator</code>类和一个<code>checker</code>类，<code>generator</code>将同一个值赋给<code>arr[16]</code>数组中的所有元素。<code>checker</code>检测<code>arr</code>数组中所有元素的值是否相等。不适用互斥锁时会出现数据完整性的问题，添加数据锁后代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = time;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checker</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] != arr[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"check fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，每次<code>generate</code>和<code>check</code>操作的时间为<code>80ms</code>，锁占用的时间也均为<code>80ms</code>，锁占用的时间较长，其他请求这个锁的线程需要等待，这样就违背了使用多线程提升效率的目的。<br>更改的方法是先将数据进行拷贝，再进行处理，在数据生成的时候，先将耗费<code>80ms</code>的生成数据存储在<code>copy</code>数组中，这个过程不需要再占用锁，然后将<code>copy</code>数组的内容复制到<code>arr</code>数组，在复制过程中需要占用锁，但是因为复制的时间很短，所以效率得到了提升，同时保证了数据的完整性。在校验过程中，可以先将<code>arr</code>数组中的值拷贝到<code>copy</code>数组中，这个过程占用锁，然后对<code>copy</code>数组的值进行校验，这个过程不需要再占用锁，这样就达到了优化的效果。优化后的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                copy[i] = time;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="built_in">memcpy</span>(arr, copy, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">16</span>);</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checker</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="built_in">memcpy</span>(copy, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">16</span>);</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(copy[i] != copy[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"check fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="可重入的函数（线程安全的函数）"><a href="#可重入的函数（线程安全的函数）" class="headerlink" title="可重入的函数（线程安全的函数）"></a>可重入的函数（线程安全的函数）</h4><p>可重入（reentrant）的函数，又称为线程安全（thread safe）的函数，是指一个函数，在多个线程里同时调用（并发调用）的时候，<strong>其功能仍然正常</strong>。在并发调用时功能出错的函数称为不可重入的函数（线程不安全）。<br>实例：线程的任务是不断的进行<code>1~n</code>的累加。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        num += i;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = sum(n);</span><br><span class="line">            <span class="keyword">if</span>(res != <span class="number">5050</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实际上上一段代码是线程安全的，但如果将<code>sum</code>函数中的变量<code>num</code>设置为全局变量，则函数变为非线程安全的，因为全局变量在不同的线程之间是可以共享的。所以线程切换时可能会导致全局变量的值不是正确的，原有逻辑受到了影响。</p>
<h6 id="判断是否可重入："><a href="#判断是否可重入：" class="headerlink" title="判断是否可重入："></a>判断是否可重入：</h6><ol>
<li>在单线程的情况下，该函数表现正常，如果单线程出了问题，说明函数写错了。</li>
<li>在多线程并发调用此函数时，如果函数仍然表现正常，则说明该函数是可重入的。</li>
</ol>
<h6 id="很可能不可重入的情况："><a href="#很可能不可重入的情况：" class="headerlink" title="很可能不可重入的情况："></a>很可能不可重入的情况：</h6><ol>
<li>一个全局函数（写在类之外的函数），借助全局对象来实现，并且有写操作，那么就是不可重入的。</li>
<li>一个类的成员函数，它访问并修改了成员变量，那么一般情况下它就是不可重入的。</li>
</ol>
<h6 id="将不可重入转换成可重入的"><a href="#将不可重入转换成可重入的" class="headerlink" title="将不可重入转换成可重入的"></a>将不可重入转换成可重入的</h6><ol>
<li>不借助外部变量，尽量使用本函数内定义的局部变量来实现。或者在本函数动态创建对象，并在退出前销毁对象。没有外部依赖，不操作外部变量。</li>
<li>实在不行的话可以加上互斥锁控制。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/线程（2）/" data-id="cjhm0p18u000gkpqww0a5uawd" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/26/线程（1）/" class="article-date">
  <time datetime="2018-04-26T13:09:31.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/26/线程（1）/">线程（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>main</code>函数是主线程，即使没有使用其他的线程，这条主线程也一直存在，主线程退出所有的线程整个程序就都退出了。使用<code>Thread</code>技术创建的线程，它们用于运行并发的任务。普通函数的调用是无法实现并行的任务的。</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>假如只有一个<code>CPU</code>，所有的线程共享这个<code>CPU</code>。</p>
<ol>
<li>每个线程都要自觉的让出<code>CPU</code>，使得其他线程也有机会被运行。可以使用<code>Sleep</code>实现。</li>
<li>操作系统会把时间分割成很细的小片（时间片），让每个线程都会有机会运行几毫秒，轮流运行。（宏观上感觉是线程在并行执行）。</li>
<li>使用<code>Sleep</code>函数让一个线程处于休眠状态，当一个线程休眠时，<code>CPU</code>会供其他线程使用。操作系统会统一进行调度，决定哪个线程被执行。</li>
</ol>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>当<code>Task1.exe</code>被加载到内存中运行时，运行的实例成为一个进程。（可以在任务管理器中查看），<code>Task1.exe</code>称为程序文件，它可以同时被运行多次，每运行一次，一个新的进程就被创建。一个进程中可以创建多个线程，其中至少有一个主线程。由操作系统负责安排调度；决定哪一个线程被运行。不同操作系统遵循同一个原则，尽可能让所有的线程都有机会运行。</p>
<h4 id="调度方法-时间片法："><a href="#调度方法-时间片法：" class="headerlink" title="调度方法 时间片法："></a>调度方法 时间片法：</h4><p>把<code>cpu</code>时间划分为均等的时间片，总体上看各个线程是被轮流运行的。线程切换过程如下：</p>
<ol>
<li>把当前的线程切到后台，进入队列等待。队列可以称为候选队列，表示里面的线程都希望自己被立刻执行。</li>
<li>从队列中取得一个正在排队的线程并运行这个线程。</li>
<li><code>5ms</code>后再次进行切换（时间片为<code>5ms</code>）</li>
</ol>
<p>需要知道</p>
<ol>
<li>使用<code>Sleep</code>函数，可以主动让自己的线程提前让出<code>CPU</code>。</li>
<li><code>Sleep</code>时间到的时候，线程并不是立即执行的，而是进入了候选队列。如果设定了N毫秒，实际间隔的时间会大于N。一般会支持到毫秒量级。</li>
<li>由操作系统决定如何在候选队列里挑选下一个线程。</li>
</ol>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>某些操作系统可能支持线程的优先级，<code>Priority</code>。允许我们再创建线程的时候，指定一下线程的优先级。如果优先级较高，则该线程在运行的时候拥有较高的机会被调度。但是可能不可靠，不是所有的系统都支持，并且可能无法定量。</p>
<h4 id="线程创建与启动"><a href="#线程创建与启动" class="headerlink" title="线程创建与启动"></a>线程创建与启动</h4><p>例如使用<code>osapi</code>库，定义一个Task类，继承于<code>OS_Thread</code>，重写线程主函数<code>Routine()</code>（这是一个虚函数），使用时<code>MyTask task; task.Run();</code>。在多数系统中，线程的创建和启动是一个连续的动作。线程属于系统级资源，可以在“资源管理器”中查看每个进程的线程数。创建线程是操作系统进行的，不能直接调用<code>Routine</code>函数。调用<code>Run</code>函数时，相当于对<code>OS</code>说“请创建一个线程，入口函数为<code>Routine()</code>”，OS则根据程序员的要求，创建一个线程实体来运行，线程的主函数就是<code>Routine()</code>。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">OS_Thread_Proc_Linux</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OS_Thread* thrd = (OS_Thread*) param;</span><br><span class="line">    thrd-&gt;Routine();  <span class="comment">//Routine函数声明virtual int Routine() = 0;</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> OS_Thread::Run()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Thread_Priv* priv = <span class="keyword">new</span> OS_Thread_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    m_Priv = priv;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;priv-&gt;hThread, <span class="literal">NULL</span>, OS_Thread_Proc_Linux, <span class="keyword">this</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>Run</code>函数后，主要通过调用<code>pthread_create</code>函数创建线程，实际上线程主函数是<code>OS_Thread_Proc_Linux</code>，然后在这个函数中由调用了程序员重载的纯虚函数<code>Routine</code>。</p>
<h6 id="两种语境"><a href="#两种语境" class="headerlink" title="两种语境"></a>两种语境</h6><ol>
<li><code>OS_Thread:</code>它是一个<code>C++</code>类/对象，封装了线程相关数据和操作。</li>
<li>线程实体：由操作系统创建的实体，通常说的线程指的是线程实体，是一个运行时的概念。<h6 id="线程是有限的资源"><a href="#线程是有限的资源" class="headerlink" title="线程是有限的资源"></a>线程是有限的资源</h6>线程是系统级资源，线程的切换和调度也是有成本的，所以一个进程中的最大线程数是有限制的，一般为几千到几万。在工程实践中，一般线程数最多为几十个。</li>
</ol>
<h4 id="线程的停止和回收"><a href="#线程的停止和回收" class="headerlink" title="线程的停止和回收"></a>线程的停止和回收</h4><h6 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h6><p>在<code>osapi</code>中，当<code>return</code>语句被执行时，表示该线程正常退出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"do something \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//线程主函数退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>return</code>语句被执行、<code>Routine()</code>函数返回，线程退出。</p>
<h6 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h6><p>当主线程（主程序）退出的时候，所有的线程都会被立即终止，即使有线程正在运行。这种终止时不正常的，有可能会造成数据的不完整。<br>例如主函数中添加了<code>getchar</code>函数，当没有<code>getchar</code>函数时，主线程会一直执行，执行完毕后立即退出，所以其他线程也可能会异常终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Buddhist task1;</span><br><span class="line">    task1.Run(); <span class="comment">//线程1</span></span><br><span class="line">    Confucian task2;</span><br><span class="line">    task2.Run(); <span class="comment">//线程2</span></span><br><span class="line">    getchar(); <span class="comment">//输入回车主线程终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="线程的回收"><a href="#线程的回收" class="headerlink" title="线程的回收"></a>线程的回收</h6><p>使用<code>OS_Thread::Join(&amp;task);</code>等待线程的退出，函数实现如下，实际上是对pthread_join函数进行了封装。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OS_Thread::Join(OS_Thread* thrd)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Thread_Priv* priv = (OS_Thread_Priv*) thrd-&gt;m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(priv)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_join(priv-&gt;hThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        thrd-&gt;m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Join</code>函数的作用：</p>
<ol>
<li>等待目标线程的退出，如果目标线程尚未退出，则会一直等待，直到其退出为止。</li>
<li>回收这个线程的相关系统资源（线程的个数是受限的）。</li>
</ol>
<p><code>Join</code>的调用：当一个线程A要退出时，由另一个线程调用来回收线程A。需要注意的是：<code>Join</code>不能回收自己。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Join(<span class="keyword">this</span>); <span class="comment">//出错的，不能自己join自己</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以由主线程或者任何一个其他线程执行<code>Join</code>。<code>Join</code>的位置：不能只看字面上的位置，而是要从运行的角度来看待问题，例如如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buddhist</span>:</span> <span class="keyword">public</span> OS_Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_quitfalg = <span class="literal">false</span>;</span><br><span class="line">        Run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_quitfalg = <span class="literal">true</span>;</span><br><span class="line">        Join(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_quitfalg;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; !m_quitfalg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ma mi ma mi hong..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            OS_Thread::Sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"善后工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，<code>Join</code>函数位于创建线程类的<code>stop</code>函数中，并且将<code>this</code>作为参数，但实际上这种写法是正确的，因为<code>stop</code>函数是在主函数即主线程中调用，虽然代码中使用<code>Join(this)</code>，但实际上并不是自己等待自己。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/26/线程（1）/" data-id="cjhm0p18m000ekpqwo3qebto1" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Building-C-Projects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/Building-C-Projects/" class="article-date">
  <time datetime="2018-04-25T13:59:56.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/Building-C-Projects/">Building C Projects</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要对构建C项目的过程进行描述，主要参考这篇博客(<a href="http://nethack4.org/blog/building-c.html" target="_blank" rel="noopener">http://nethack4.org/blog/building-c.html</a>)<br></p>
<ol>
<li>配置（Configuration）</li>
<li>标准目录检测（Standard directory detection）</li>
<li>源文件依赖计算（Source file dependency calculation）</li>
<li>头文件定位（Head file location）</li>
<li>头文件预编译（Header precomplition）</li>
<li>预处理（Preprocessing）</li>
<li>编译和汇编（Compilation and assembly）</li>
<li>目标文件依赖计算（Object file dependency calculation）</li>
<li>链接（linking）</li>
<li>安装（Installation）</li>
<li>资源链接（Resource linking）</li>
<li>包生成（Package generation）</li>
<li>动态链接（Dynamic linking）<br>主要过程如上所示，实际上C不一定要按照上述步骤构建。如果按部就班的讲解很难描述清楚，因为有些步骤是接下来一些步骤的准备，很容易让人迷惑，所以从第6部开始慢慢延伸。</li>
</ol>
<h4 id="6：-Preprocessing"><a href="#6：-Preprocessing" class="headerlink" title="6： Preprocessing"></a>6： Preprocessing</h4><p>使用下面的c程序作为示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Hello, world!\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们首先要关注第一行<code>#include&lt;stdio.h&gt;</code>，一个常见的误解是这行程序与一些库有关系，它将fputs的定义与库中的程序联系在一起。实际上这行代码只是告诉编译器fputs和stdout所拥有的类型，等同于下面代码（省略了很多不相关的代码）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, FILE *)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Hello, world!\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上与链接没有关系，stdio.h只是一些类型、函数、变量和宏定义的声明列表。C标准对于编译器如何实现这些定义没有任何限制，但实际上，类似stdio.h这样的头文件几乎都由轻量扩展的C程序实现。在这个例子中FILE是一个不完全的类型，extern意味着只是一个声明，不一定包含函数或变量的定义。<br><br>预处理同时会移除源文件中的注释。如今，预处理阶段经常与编译阶段同时进行，但是预处理阶段也是可以单独进行的，使用-E指令进行预处理操作，预处理后的文件后缀为.i。</p>
<h4 id="5：Header-precomplition"><a href="#5：Header-precomplition" class="headerlink" title="5：Header precomplition"></a>5：Header precomplition</h4><p>不同的源码文件可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译，为了节省时间，并且如果头文件的声明有错误，每个包含该头文件的程序都会出现相同错误，无论是否与这个错误相关联，编译器会在编译源码之前，先编译头文件。这保证头文件只需要编译一次，不过并不是头文件的所有内容都会被预编译。例如用来声明宏的#define指令，就不会被预编译。</p>
<h4 id="4：Header-file-location"><a href="#4：Header-file-location" class="headerlink" title="4：Header file location"></a>4：Header file location</h4><p>为了能够包含头文件，必须能够在文件系统中找到，大多数预处理使用的方法都很简单，可以使用一个硬编码的目录列表，用户可以将其添加到目录中，预处理时会按照顺序进行扫描，知道找到正在查找的文件。<br><br>当项目较大时，也可以通过扫描经过适当命名的头文件资源树，然后通过比较路径（根据目录结构采用最接近的匹配头文件）来计算出哪个头文件是预期的。当使用分层构建时，项目的不同部分必须放置在不同的目录中，采用这种方法使较为明智的。</p>
<h4 id="3：Source-file-dependency-calculation"><a href="#3：Source-file-dependency-calculation" class="headerlink" title="3：Source file dependency calculation"></a>3：Source file dependency calculation</h4><p>对于大型项目，源码文件之间往往存在着依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。<br><br>（1）只有在B文件编译完成后，才开始编译A文件。<br><br>（2）当B文件发生变化时，A文件才能被重新编译。<br><br>如今依赖自动化的方法主要通过预处理器对包含的每个头文件进行报告（大多数可以直接生成makefile片段），这会引发chicken-and-egg问题（只有通过编译才能计算出依赖，只有获取依赖才能顺利编译）。标准的方法是首先在没有依赖的情况下进行构建，这满足了第一点要求，但是第二点并不满足。<br>编译顺序保存在makefile文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须先运行的原因。在确定依赖关系的同时，编译器也确定了编译时会用到哪些头文件。</p>
<h6 id="2：Standard-directory-detection"><a href="#2：Standard-directory-detection" class="headerlink" title="2：Standard directory detection"></a>2：Standard directory detection</h6><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。<br><br>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p>
<h6 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1: Configuration"></a>1: Configuration</h6><p>在编译器开始工作之前，需要知道当前系统的环境，比如标准库在哪里，软件安装在哪里，需要安装哪些组件等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的代码。这个确定编译参数的步骤，就叫做配置（Configuration）。<br><br>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。<br><br>configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/www --with-mysql</span><br></pre></td></tr></table></figure></p>
<p>上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。</p>
<h4 id="7-Compilation-and-assembly"><a href="#7-Compilation-and-assembly" class="headerlink" title="7: Compilation and assembly"></a>7: Compilation and assembly</h4><p>预处理阶段输出的是轻微扩展的C代码，目标文件（链接器的输入）则是轻微修改的机器码，与处理器实际运行的机器代码的区别在于它充满了与链接器相关的指令以及与处理器相关的指令。<br><br>有两种方法可以将c代码转换成机器码。一种方法是直接进行转换，另外一种是通过汇编代码，即通过编译和汇编两个过程，汇编代码可以通过C代码执行-S指令获得，也可以通过对目标文件进行反汇编获得。上述示例的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;t.c&quot;</span><br><span class="line">.section    .rodata             Contents of section .rodata:</span><br><span class="line">.LC0:</span><br><span class="line">.string &quot;Hello, world!\n&quot;       Hello, world!..</span><br><span class="line">.text                           Disassembly of section .text:</span><br><span class="line">.globl  main</span><br><span class="line">.type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq   %rbp                    push   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp              mov    %rsp,%rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">movq    stdout(%rip), %rax      mov    0x0(%rip),%rax</span><br><span class="line">movq    %rax, %rcx              mov    %rax,%rcx</span><br><span class="line">movl    $14, %edx               mov    $0xe,%edx</span><br><span class="line">movl    $1, %esi                mov    $0x1,%esi</span><br><span class="line">movl    $.LC0, %edi             mov    $0x0,%edi</span><br><span class="line">call    fwrite                  callq  22 &lt;main+0x22&gt;</span><br><span class="line">movl    $0, %eax                mov    $0x0,%eax</span><br><span class="line">popq    %rbp                    pop    %rbp</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.size   main, .-main</span><br><span class="line">.ident  &quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot;</span><br><span class="line">.section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码包括一些与链接器相关的信息，有些在机器码中是不存在的。汇编代码中有很多段来告诉链接器不同数据存储的位置，main函数从.text开始，.rodate代表只读，.cfi_代表生成栈展开信息，例如可以通过objdump -d test.o获得反汇编代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format elf64-x86-64          </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:                  </span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:                        </span><br><span class="line">   0:   55                      push   %rbp      </span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp  </span><br><span class="line">   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax</span><br><span class="line">   b:   48 89 c1                mov    %rax,%rcx</span><br><span class="line">   e:   ba 0e 00 00 00          mov    $0xe,%edx</span><br><span class="line">  13:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  18:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  1d:   e8 00 00 00 00          callq  22 &lt;main+0x22&gt;</span><br><span class="line">  22:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  27:   5d                      pop    %rbp</span><br><span class="line">  28:   c3                      retq</span><br></pre></td></tr></table></figure></p>
<p>使用objdump -x命令可以生成symbol table，可以对符号表中的值进行定位。使用-S命令进行编译，使用-c进行汇编。</p>
<h4 id="8-Object-file-dependency-calculation"><a href="#8-Object-file-dependency-calculation" class="headerlink" title="8: Object file dependency calculation"></a>8: Object file dependency calculation</h4><p>一旦生成了目标文件，下一步要考虑的是如何将这些目标文件组合在一起生成可执行文件。为了生成可执行文件，需要获得满足依赖关系的目标文件和相关库的列表，在这些目标文件中出现的任何未定义的符号都需要被其他的目标文件所定义，同时也需要提供开始运行的入口点。<br><br>对于每个主函数都有一个可执行文件，可以通过递归的查找未定义符号所依赖的库或目标文件。</p>
<h4 id="9-Linking"><a href="#9-Linking" class="headerlink" title="9: Linking"></a>9: Linking</h4><p>一旦了解需要组合哪些目标文件来生成可执行文件，下一步通过链接器生成可执行文件，观察第七步生成的汇编代码，会发现其中引用了stdout函数和fwrite函数。也就是说程序要正常运行，还需要stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。<br><br>编译器下一步工作是把外部函数的代码（通常后缀名为.lib和.a的文件），添加到可执行文件中，其中涉及到内存地址的定位等。这种通过拷贝，将外部函数添加到可执行文件的方式叫做静态链接。后文还会提到动态链接。<br>make命令的作用是从第五步到这一步结束。</p>
<h4 id="10-Installation"><a href="#10-Installation" class="headerlink" title="10: Installation"></a>10: Installation</h4><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。表面上这个过程很简单，就是将可执行文件（连带相关的数据文件）拷贝过去即可。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就成为“安装”。</p>
<h4 id="11-Resource-Linking"><a href="#11-Resource-Linking" class="headerlink" title="11: Resource Linking"></a>11: Resource Linking</h4><p>资源链接通常和安装过程同时进行，正常的方法是手动编写构建规则以执行相关步骤。在windows上，VS在链接后立即执行资源链接。</p>
<h4 id="12-Package-generation"><a href="#12-Package-generation" class="headerlink" title="12: Package generation"></a>12: Package generation</h4><p>到这里，源码编译的过程就基本完成了。但事实上，如果只有源码可以交给用户是很不友好的。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，能够将上一步生成的可执行文件做成可以分发的安装包。所以编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关数据文件）以某种目录结构保存成压缩文件包交给用户。</p>
<h4 id="13-Dynamic-Linking"><a href="#13-Dynamic-Linking" class="headerlink" title="13: Dynamic Linking"></a>13: Dynamic Linking</h4><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。<br><br>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。<br><br>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/Building-C-Projects/" data-id="cjhm0p1700000kpqwrixix37t" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HSI/">HSI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM/">LLVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/effective-c/">effective c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复习/">复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HSI/" style="font-size: 10px;">HSI</a> <a href="/tags/LLVM/" style="font-size: 20px;">LLVM</a> <a href="/tags/effective-c/" style="font-size: 15px;">effective c++</a> <a href="/tags/复习/" style="font-size: 20px;">复习</a> <a href="/tags/线程/" style="font-size: 20px;">线程</a> <a href="/tags/网络/" style="font-size: 20px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/14/面试复习（3）/">面试复习（3）</a>
          </li>
        
          <li>
            <a href="/2018/05/11/effective-c-（2）/">effective-c++（2）</a>
          </li>
        
          <li>
            <a href="/2018/05/08/effective-c-（1）/">effective c++（1）</a>
          </li>
        
          <li>
            <a href="/2018/05/01/网络（3）/">网络（3）</a>
          </li>
        
          <li>
            <a href="/2018/04/30/网络（2）/">网络（2）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 小白拜拜拜<br>
  	  <span id="busuanzi_container_site_pv">
         本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span> 
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
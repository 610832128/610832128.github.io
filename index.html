<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小白拜拜拜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小白拜拜拜">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小白拜拜拜">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小白拜拜拜">
  
    <link rel="alternate" href="/atom.xml" title="小白拜拜拜" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小白拜拜拜</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网络（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/01/网络（3）/" class="article-date">
  <time datetime="2018-05-01T11:55:20.000Z" itemprop="datePublished">2018-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/01/网络（3）/">网络（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h4><p><code>TCP: Transmission control protocal</code>，传输控制协议，是与<code>UDP</code>并列的两个传输协议。</p>
<h5 id="C-S设计模式"><a href="#C-S设计模式" class="headerlink" title="C/S设计模式"></a>C/S设计模式</h5><p><code>TCP</code>的设计模式成为<code>C/S</code>，即<code>Client-Server</code>（客户机-服务器）模式（<code>UDP</code>两端是对等的，<code>TCP</code>两端是不对等的，一端称为<code>Client</code>，另一端称为<code>Server</code>）。<br>对于<code>TCP</code>，客户端和服务器的写法是不同的。</p>
<ol>
<li>客户端<ol>
<li>连接服务器<code>connect</code>。</li>
<li>通讯</li>
</ol>
</li>
<li>服务器<ol>
<li>主<code>socket</code>接收连接<code>Accept</code>。</li>
<li>有连接到来时，创建一个<code>Working Socket</code>为<code>Client Socket</code>提供服务。每一个<code>Client</code>都分配一个<code>Socket</code>，专门的一对一的提供服务。</li>
</ol>
</li>
</ol>
<p>例如：银行服务热线<code>95555</code>，一个客户（<code>Client Socket</code>）拿起电话拨打服务<code>95555</code>，<code>connect(95555)</code>。接通（<code>connected</code>），你的电话转接到一个工作人员（<code>Working Socket</code>）。<br><code>TCP</code>中应该使用多线程技术。</p>
<h6 id="服务器："><a href="#服务器：" class="headerlink" title="服务器："></a>服务器：</h6><ol>
<li><code>serv_sock.Open(OS_SockAddr(9555), true);</code></li>
<li><code>serv_sock.Listen();</code></li>
<li><code>serv_sock.Accept(&amp;work_set);</code></li>
</ol>
<h6 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h6><ol>
<li><code>Open(), Connect()</code></li>
<li><code>Send/Recv</code></li>
</ol>
<p>代码实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">OS_TcpSocket client;</span><br><span class="line">client.Open();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n = client.Connect(peer);</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection fail!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[maxLen];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//gets(buf);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    client.Send(buf, len);</span><br><span class="line">    len = client.Recv(buf, maxLen);</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">client.Close();</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端，使用了多线程，每次监听到一个连接就新建一个线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work_thread</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Work_thread(OS_TcpSocket work_sock)</span><br><span class="line">	&#123;</span><br><span class="line">		maxLen = <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;work_sock = work_sock;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	OS_TcpSocket work_sock;</span><br><span class="line">	<span class="keyword">int</span> maxLen;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[maxLen];</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> n = work_sock.Recv(buf, maxLen);</span><br><span class="line">			<span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			buf[n] = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">strcpy</span>(buf, <span class="string">"ok!"</span>);</span><br><span class="line">			<span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">			work_sock.Send(buf, len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OS_TcpSocket server;</span><br><span class="line">server.Open(OS_SockAddr(<span class="number">8888</span>), <span class="literal">true</span>);</span><br><span class="line">server.Listen();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"服务器启动"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    OS_TcpSocket work_set;</span><br><span class="line">    <span class="keyword">int</span> status = server.Accept(&amp;work_set);</span><br><span class="line">    <span class="keyword">if</span>(status &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Work_thread* conn = <span class="keyword">new</span> Work_thread(work_set);</span><br><span class="line">    conn-&gt;Run();</span><br><span class="line">    <span class="comment">//Work_thread conn(work_set); conn.Run(); 这样会报错，还不清楚原因</span></span><br><span class="line">&#125;</span><br><span class="line">server.Close();</span><br></pre></td></tr></table></figure></p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>请求应答模式，一般情况下，需要客户端发起一个请求，然后服务器做出针对性的应答。</li>
<li>服务器应该处于常开状态，服务器应该保持一直运行，随时等到客户端发送请求。</li>
<li><code>Send/Recv</code>不需要再指定目标地址，因为在<code>Connect</code>成功之后，<code>Client</code>和服务器的某个<code>Working Socket</code>已经配对，是一对一的进行通话。</li>
<li>服务器一般只需要指定端口号。<code>OS_SockAddr(9555)</code>相当于<code>OS_SockAddr(&quot;0000&quot;</code> <code>, 9555)</code>。</li>
</ol>
<h4 id="TCP内部缓冲区"><a href="#TCP内部缓冲区" class="headerlink" title="TCP内部缓冲区"></a>TCP内部缓冲区</h4><p><code>UDP Socket</code>的缓冲区：包式存取，每个包带地址。<br><code>TCP Socket</code>的缓冲区：流式存取，每个包不带地址。分界是自由的。例如两次发送<code>&quot;hello&quot;</code>和<code>&quot;world&quot;</code>，服务可能一次就输出了<code>helloworld</code>。</p>
<h5 id="定义边界"><a href="#定义边界" class="headerlink" title="定义边界"></a>定义边界</h5><p>设计交互协议时，要自己定义消息的边界。<code>a-&gt;b(请求) a&lt;-b(应答) a-&gt;b(请求) a&lt;-b(应答)</code>，有两种方法：</p>
<ol>
<li>先发长度，后发数据<code>00 05 &#39;h&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39;</code></li>
<li>每段消息加上结束符(结束符不属于正文)，<code>hello\r\n</code><br>主要代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">buf = getBuf(work_sock, <span class="number">2</span>);  <span class="comment">//获取数据长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> num = cTos(buf);</span><br><span class="line">buf = getBuf(work_sock, num); <span class="comment">//根据长度获取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">getBuf</span><span class="params">(OS_TcpSocket sock, <span class="keyword">unsigned</span> <span class="keyword">short</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[num];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(count &lt; num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = sock.Recv(buf + count, num - count);</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		count += n;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[num] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><ol>
<li><code>Send</code>阻塞：当<code>SendBuf</code>满时。</li>
<li><code>Recv</code>阻塞：当<code>RecvBuf</code>满时。<br><code>Socket</code>默认是阻塞方式，也可以手工设置为非阻塞方式。</li>
</ol>
<h5 id="设置获取缓冲区"><a href="#设置获取缓冲区" class="headerlink" title="设置获取缓冲区"></a>设置获取缓冲区</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取sendbuf大小</span></span><br><span class="line"><span class="keyword">int</span> bufsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ret = getsockopt(client_sock.hSock, SOL_SOCKET,</span><br><span class="line">        SO_SNDBUF, <span class="comment">//SO_RCVBUF</span></span><br><span class="line">        (<span class="keyword">char</span>*)&amp;bufsize, &amp;len);</span><br><span class="line"><span class="comment">//设置sendbuf大小</span></span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> ret = setsocketopt(client_sock.hSock, SOL_SOCKET,</span><br><span class="line">        SO_SNDBUF,</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;bufsize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<h4 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h4><p>交换机职责：交换数据，将从一个口进入的数据包（包括源地址和目标地址），转发到其他的口。如何转发完全由交换机决定。一种情况是直接将数据包转发到每一个口，另一种情况是交换机上记录了每个口的主机<code>IP</code>，选择对应的口转发。使用<code>wireshark</code>可以发现网口上接收到的数据包，有的目标<code>IP</code>不是自己这台主机的。</p>
<ol>
<li>发送：<code>OS</code>把数据包通过网卡、上行传至交换机。</li>
<li>接收：<code>OS</code>从网卡获取数据包。</li>
</ol>
<h5 id="UDP传输"><a href="#UDP传输" class="headerlink" title="UDP传输"></a>UDP传输</h5><p>正常流程</p>
<ol>
<li>主机<code>A</code>发送一个<code>UDP</code>包，此包抵达交换机的<code>1</code>口。</li>
<li>交换机没有干预，此包复制到<code>2、3、4</code>口。</li>
<li>处于<code>2</code>口的主机<code>B</code>，接收到这个包。<br>不正常情况<br>交换机丢到了这个包。没有转到<code>2</code>口。问题是主机<code>A</code>无法知道这个包是否抵达目标主机。</li>
</ol>
<h5 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h5><p>三次握手和四次握手。<br><img src="/images/tcp.jpg" alt=""></p>
<p><code>TCP</code>称为可靠地传输协议，因为发送端能够知道这个包有没有抵达目标，并且底层有重发机制。<code>UDP</code>的<code>SendTo</code>不会失败，它只是把数据包送出去，不管到达与否。<code>TCP</code>的<code>Send</code>包会失败，当网络不可抵达时（未收到<code>ACK</code>），就是发送失败了。</p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p><code>select</code>查询机制，本质是一个函数，用来向<code>OS</code>查询：在一堆<code>socket</code>中，查出可以读写的<code>socket</code>。<code>OS_Socket</code>类做了一个简单的封装。不能读因为缓冲区是空的，不能写因为缓冲区是满的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int Select_ForReading(int timeout);</span><br><span class="line">int Select_ForWriting(int timeout);</span><br></pre></td></tr></table></figure></p>
<p>用途：如果服务器同时与大量的客户端交互，可以用<code>select</code>查询哪些<code>socket</code>有上行的数据，如果有数据才做响应。这样就没有必要为每个<code>client</code>创建单独的一个线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/01/网络（3）/" data-id="cjgnmh0fx000kjpqwhitaf2zv" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/30/网络（2）/" class="article-date">
  <time datetime="2018-04-30T04:13:32.000Z" itemprop="datePublished">2018-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/30/网络（2）/">网络（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><h5 id="按照字节传输"><a href="#按照字节传输" class="headerlink" title="按照字节传输"></a>按照字节传输</h5><p>网络上的数据是一个字节一个字节串行传递的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"hello"</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">5</span>, ...)</span><br></pre></td></tr></table></figure></p>
<p>那么在信道中依次传输5个字节：<code>68 65 6c 6c 6f</code>。</p>
<h5 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h5><p>当观察到一个<code>unsigned int</code>型变量的内存,<code>unsigned int a = 0x12345678;</code><br>在内存中的排列为<code>78 56 34 12</code>，却不是<code>12 34 56 78</code>，原因是因为这是一种规定。<br>小端：低位字节在内存的低地址端，高位字节在内存的高地址端。主流系统都是小端的（<code>intel/amd</code>）<br>大端：低位字节在内存的高地址端，高位字节在内存的低地址端。</p>
<h5 id="网络传输字节序"><a href="#网络传输字节序" class="headerlink" title="网络传输字节序"></a>网络传输字节序</h5><p>网络传输的时候，惯例是按照大端传输的。即把接收到的第一个字节当做高位字节看待，这就要求发送端发送的第一个字节是高位字节，而在发送端发送数据时，发送的第一个字节应该是数值在内存中的起始地址对应的那个字节（即高位字节存放在低地址），将小端转换为大端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itob_32be</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bytes[<span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    bytes[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    bytes[<span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    bytes[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h4><h5 id="默认分配端口号"><a href="#默认分配端口号" class="headerlink" title="默认分配端口号"></a>默认分配端口号</h5><p>发送方<code>Socket</code>可以不显式的指定端口号：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UdpSocket sock;</span><br><span class="line">sock.open(); <span class="comment">//不带地址</span></span><br><span class="line">sock.SendTo(); <span class="comment">//发送数据</span></span><br></pre></td></tr></table></figure></p>
<p><code>SendTo</code>函数被调用时，<code>OS</code>发现这个<code>Socket</code>还没有分配端口号，于是立即为其自动分配一个端口号，然后进行发送，接收方必须指定端口号的，发送方自动分配的端口号有一个区间，一般在<code>10000</code>以上。可以通过以下方式查看：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_SockAddr local;</span><br><span class="line">sock.GetLocalAddr(local);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port = local.GetPort();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"local port: %d \n"</span>, port);</span><br><span class="line"><span class="comment">//在发送数据时，才会自动分配端口</span></span><br></pre></td></tr></table></figure></p>
<h5 id="端口的占用"><a href="#端口的占用" class="headerlink" title="端口的占用"></a>端口的占用</h5><p>当一个<code>Socket</code>使用了某个端口，那么直到这个<code>Socket</code>被关闭，这个端口都处于被占用的状态。如果还想创建一个<code>Socket</code>，并且使用相同的端口，则创建失败。<code>sock.open()</code>返回-1。所以将端口号设置为可重用的。<code>sock.open</code>第二个参数即是能否重用的选项（内部间接调用了<code>SetOpt_ReuseAddr</code>这个函数）。一般要设置为<code>true</code>，因为有时候程序会意外关闭，即时重新启动当操作系统还没有释放这个端口时，会出现错误。</p>
<h5 id="多个发送方，一个接收方"><a href="#多个发送方，一个接收方" class="headerlink" title="多个发送方，一个接收方"></a>多个发送方，一个接收方</h5><p>接收方可以区分一个消息是谁发送的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">OS_SockAddr peer;</span><br><span class="line"><span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br></pre></td></tr></table></figure></p>
<p><code>RecvFrom</code>只是从“接受缓冲区”里取出一个数据包，这个数据包本身是带有源地址的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> peer_ip = peer.GetIp_str();</span><br><span class="line"><span class="keyword">int</span> peer_port = peer.GetPort();</span><br></pre></td></tr></table></figure></p>
<h5 id="阻塞与超时"><a href="#阻塞与超时" class="headerlink" title="阻塞与超时"></a>阻塞与超时</h5><h6 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h6><p>接收方<code>sock.RecvFrom</code>：</p>
<ol>
<li>如果<code>RecvBuf</code>中有数据，则函数立即返回。</li>
<li>如果没有数据，则函数会一直等待，知道有数据时才取出数据，这个等待行为就是“阻塞”方式，可以设置最大等待时间，超过后如果仍然没有数据，函数返回-1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.SetOpt_RecvTimeOut(<span class="number">3000</span>) <span class="comment">//超过3s仍无数据，则RecvFrom返回-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h6><p>不管有没有数据，函数都立即返回，如果有数据，则返回值<code>&gt;0</code>，如果没有数据，则返回值为<code>-1</code>。此时，需要程序定时的去调用<code>RecvFrom</code>函数去查看有没有数据，这种设计模式叫做“轮询”。</p>
<h4 id="双工通讯"><a href="#双工通讯" class="headerlink" title="双工通讯"></a>双工通讯</h4><p><strong>单工</strong>：单向通信，A只能发信号，B只能接收信号，通信是单向的。（广播、电视）<br><strong>半双工</strong>： 双向通信但是不能同时进行，A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。（要么上行（上传），要么下行（下载），比如对讲机）<br><strong>全双工</strong>：双向通信互不影响，A给B发信号的同时，B也可以给A发信号。（上行下行可同时进行，手机、电话）<br><code>UDP</code>是双工的。可以使用多线程的方式实现全双工操作，一个线程负责读，另一个线程负责写。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        OS_UdpSocket sock;</span><br><span class="line">        sock.Open();</span><br><span class="line">        <span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            sock.SendTo(buf, len, peer);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.Close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recv</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        OS_UdpSocket sock;</span><br><span class="line">        sock.Open(OS_SockAddr(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>), ture);</span><br><span class="line">        OS_SockAddr peer;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buf[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.Close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>协议，<code>protocal</code>，协议就是规定，是通信双方事先协商好的规则。它规定了数据的格式。没有协议，就无法实现数据的传输（对方读不懂）。<br>当要传递一个整数<code>0x12345678</code>给对方时，可以有多种方式。</p>
<ol>
<li>大端，按字节，<code>12 34 56 78</code>。</li>
<li>小端，按字节，<code>78 56 34 12</code>。</li>
<li>文本，十六进制， “<code>12345678</code>“（共八个字节）。</li>
<li>文本, 十进制，”<code>305419896</code>“（共九个字节）。<br>双方协商好按格式1进行传输，这便是协议。</li>
</ol>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>通过<code>UDP</code>传输，A发送B一个文件，协议如下：</p>
<ol>
<li>把文件分块传输，每块最大1024个字节。</li>
<li>数据包格式，前16字节表示指令<br> 01 开始传送 02 数据包 FF 结束传送</li>
</ol>
<p>主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open();</span><br><span class="line">File *fp = fopen(<span class="string">"123.tar"</span>, <span class="string">"rb"</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_SockAddr local;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"please input enter: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">getchar();</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">16</span>, peer);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = fread(buf + <span class="number">16</span>, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">    sock.SendTo(buf, n + <span class="number">16</span>, peer);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"send data packet, count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">16</span>, peer);</span><br><span class="line">sock.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open(local, <span class="literal">true</span>);</span><br><span class="line">OS_SockAddr peer;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">1024</span> + <span class="number">16</span>];</span><br><span class="line">FILE* fp = fopen(<span class="string">"456.tar"</span>, <span class="string">"wb"</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">1024</span> + <span class="number">16</span>; peer);</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0x01</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection start"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0xFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection end"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(buf + <span class="number">16</span>, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"receive packet, count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="强化协议，减少丢包不怕丢包"><a href="#强化协议，减少丢包不怕丢包" class="headerlink" title="强化协议，减少丢包不怕丢包"></a>强化协议，减少丢包不怕丢包</h5><ol>
<li>A控制发送节奏，不要太快。使用线程的<code>sleep</code>函数。</li>
<li>确定应答模式，接收到应答后才发下一个包。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/30/网络（2）/" data-id="cjgnmh0fv000ijpqwc7j7if74" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/网络（1）/" class="article-date">
  <time datetime="2018-04-27T14:21:22.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/网络（1）/">网络（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h4><h5 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h5><ol>
<li>主机： <code>Host</code>,包含台式机、笔记本、手机等设备。</li>
<li>网络： <code>Internet</code></li>
<li>网络介质：<code>Media</code>：网线，光纤，无线网域网<code>wifi</code>，移动<code>3G</code>网络。</li>
<li>数据：<code>Data</code>，一串字节。</li>
</ol>
<h5 id="网络通讯观测"><a href="#网络通讯观测" class="headerlink" title="网络通讯观测"></a>网络通讯观测</h5><p><code>wireshark</code>，“抓包”工具，抓，<code>capture</code>。包，<code>packet</code>,数据包。</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p><code>Internet protocol Address</code>，网络协议地址，用于标识网络上的一台主机。<br>通常采用4字节表示，称为<code>IPv4</code>。用字符串表示时，采用10进制，以点号分开：<br><code>&quot;192.168.1.1&quot;</code>（家庭路由器地址）、<code>&quot;123.57.248.214&quot;</code>,用16进制表示<code>C0 A8 01 01</code>、<code>7B 39 F8 D6</code>。</p>
<h5 id="ping：检测连通"><a href="#ping：检测连通" class="headerlink" title="ping：检测连通"></a>ping：检测连通</h5><p><code>windows/linux</code>下都有<code>ping</code>命令，它可以检查对方的主机是否能够连通。<code>ping 123.27.148.124</code>。如果能连通说明对方主机在线，否则请求超时有三种可能性：</p>
<ol>
<li>对方关机、离线</li>
<li>己方没有连网。</li>
<li>对方在线，但是屏蔽了<code>PING</code>服务。</li>
</ol>
<h5 id="查看自己的ip地址"><a href="#查看自己的ip地址" class="headerlink" title="查看自己的ip地址"></a>查看自己的ip地址</h5><p><code>windows: ipcofig linux: ifconfig</code></p>
<h4 id="Socket复用技术"><a href="#Socket复用技术" class="headerlink" title="Socket复用技术"></a>Socket复用技术</h4><h5 id="Socket概念"><a href="#Socket概念" class="headerlink" title="Socket概念"></a>Socket概念</h5><p>两台主机进行通讯，运行不同的程序，它们都在使用网络进行数据的传输。<br>为什么一台主机上的多个程序可以同时使用网络？引入<code>Socket</code>概念，原意为“插座”，形象的表示用一根线连接两个插座，即形成一个数据通道。每个插口可以用一个数字标识（<code>0~65535</code>），这个数字就称为端口（<code>Port</code>）。<br>两个程序要进行通讯，就要各自选择一个插口，然后连接起来。<br>程序1：在<code>192.168.1.100</code>上运行，使用端口<code>9001</code>。<br>程序2：在<code>192.168.1.101</code>上运行，使用端口<code>9002</code>。<br>连接上来，就形成了一个数据通道，它们俩之间可以交流数据了（只是逻辑上的通道）。</p>
<h5 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h5><p>在多个<code>socket</code>,每个<code>socket</code>上同时传输着不同的数据（视频、文件、网页下载等）。但是网线只有一根，字节是串行传输的，如何保证正确性？<br>可以采用<strong>封包</strong>的方法，将(<code>IP,Port</code>)放在包头。这种在一个信道中，交叉间隔的传输数据的方案，叫做“分时复用”。<code>Mux</code>，重复利用的意思。</p>
<ol>
<li>发送方：复用<code>Mux</code><br>将每个<code>Socket</code>上的数据，拆分成固定格式的小包，每个小包前面加上<code>IP/Port</code>，按照时间间隔，轮番发送到信道中。</li>
<li>接收方：解复用<code>Demux</code><br>从信道中接收小包，根据包头里的Port，将小包还原成原始数据，再分发给不同的<code>Socket</code>处理。</li>
</ol>
<h6 id="大包拆分成小包"><a href="#大包拆分成小包" class="headerlink" title="大包拆分成小包"></a>大包拆分成小包</h6><p>一边拆一边合。每个包的包头加上一些标识。分包的目的是各个Socket均匀占用网络。</p>
<h4 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h4><p><code>UDP</code>: <code>User Datagram Protocol</code>，用户数据报文协议。适用于局域网的主机间通信。两台主机上的程序，在知道了对方的<code>Socket</code>地址之后，就可以适用<code>UDP</code>传输数据。<br> 发送方：<code>UdpSocket sock; sock.sendTo(...)</code>。<br> 接收方：<code>UdpSocket sock; sock.RecvFrom(...)</code>。<br> 主要代码如下所示：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//发送方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)</span></span>; <span class="comment">//ip和端口号</span></span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open(local, <span class="literal">true</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"发送方: port 9000"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    sock.SendTo(buf, len, peer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.open(local, <span class="literal">true</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="number">0</span>; <span class="comment">//终止符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Got: "</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"bye"</span>, buf) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock.Close();</span><br></pre></td></tr></table></figure></p>
<h5 id="单机测试"><a href="#单机测试" class="headerlink" title="单机测试"></a>单机测试</h5><p>正常情况下，<code>Socket</code>编程的目的是为了将数据传送到另一台主机，因此需要两台主机才可以完成测试。例如<code>192.168.1.100 -&gt; 192.168.1.101</code>。当没有多主机环境时，可以使用单机测试，目标地址为<code>127.0.0.1</code>，表示本机。当指定发送目标为<code>127.0.0.1</code>时，发送的数据不经过网卡，直接在系统内回环送回。又称为<code>loopback</code>地址（回环地址）。<code>wireshark</code>无法监测<code>loopback</code>上的数据，因为根本没有通过网卡传送。</p>
<h5 id="多机测试"><a href="#多机测试" class="headerlink" title="多机测试"></a>多机测试</h5><p>局域网下的多机测试，可以在一台交换机上插上两台主机，构建一个局域网，然后两台主机间可以通讯。如果没有两台主机，可以使用虚拟机构建多机测试环境。保证在同一个网段，将<code>ip</code>地址与子网掩码做与运算（默认<code>255.255.255.0</code>），如果相同则在同一个网段。<code>wireshark</code>中有实现过滤和事后过滤。</p>
<h4 id="内部缓冲区"><a href="#内部缓冲区" class="headerlink" title="内部缓冲区"></a>内部缓冲区</h4><p><code>SendTo()</code>和<code>RecvFrom()</code>是由系统来完成的。那么</p>
<ol>
<li>在调用<code>SendTo</code>的时候，系统是立即发送的么？</li>
<li>在调用<code>RecvFrom</code>的时候，系统是接到命令再去接收的么？<br>在系统内部，每个<code>Socket</code>关联了两个缓冲区(<code>Buffer</code>)，一个用于发送，一个用于接收。缓冲区实际上就是一片内存，用于暂时存储数据。</li>
</ol>
<h5 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h5><ol>
<li><code>SendTo</code>把数据放在<code>SendBuf</code>里，通知<code>OS</code>来取。</li>
<li><code>OS</code>在适当的时候过来取数据，并发送到网络。<br>这意味着存入数据和发送数据存在着时间差，如果数据存入太快太多，发送缓冲区可能会满。</li>
</ol>
<h5 id="接收过程"><a href="#接收过程" class="headerlink" title="接收过程"></a>接收过程</h5><ol>
<li><code>OS</code>不停把从网络上接收的数据存储到<code>RecvBuf</code>里。</li>
<li><code>RecvFrom</code>从缓冲区中取数据。<br>这意味着不论是否去取数据，<code>OS</code>总是默默的把数据先接收下来存储好，<code>RecvFrom</code>是从<code>RecvBuf</code>里取走现成的数据。如果不及时取走，则缓冲区可能会满。</li>
</ol>
<p>发送和接收是一个异步过程，发送的时候，先把数据放入缓冲区中，然后由<code>OS</code>安排发送，接收的时候，由<code>OS</code>先接收下来存在缓冲区，而<code>RecvFrom</code>只是从缓冲区取走现成的数据。</p>
<h5 id="“缓冲区满”的处理"><a href="#“缓冲区满”的处理" class="headerlink" title="“缓冲区满”的处理"></a>“缓冲区满”的处理</h5><h6 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h6><ol>
<li>直到缓冲区有剩余空间（阻塞）。</li>
<li>新发送的数据没有存入缓冲区。</li>
</ol>
<h6 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h6><ol>
<li>新的数据不被接收。</li>
<li>删除缓冲区里的现有数据，存放新的数据<br>1和2都会引起丢包现象</li>
</ol>
<h6 id="设置发送-接收缓冲区的大小"><a href="#设置发送-接收缓冲区的大小" class="headerlink" title="设置发送/接收缓冲区的大小"></a>设置发送/接收缓冲区的大小</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setsocketopt(sock.hSock, SOL_SOCKET, <span class="comment">//opt即为option</span></span><br><span class="line">    SO_SENBUF, <span class="comment">//代表sendBuf，SO_RCVBUF代表recvBuf</span></span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;bufsize,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">int</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>设置成功与否由操作系统决定。</p>
<h6 id="丢包问题"><a href="#丢包问题" class="headerlink" title="丢包问题"></a>丢包问题</h6><p>一般情况下，设置缓冲区的大小并不能解决“丢包”问题。<br>要注意一下三个方面：</p>
<ol>
<li>发送是否均匀。</li>
<li>接收是否及时。</li>
<li>接收带宽是否超过实际传输带宽。发送数据量过大会丢包。视频包可能会出现。<br>另外，即使<code>HostA</code>和<code>HostB</code>处理的都没有问题，网络上的任意一个中间节点设备都有可能丢包。丢包问题对于<code>USP</code>来说是很常见的，再设计是就要考虑到这一点，再决定使用<code>UDP</code>的时候就应该允许丢包，要做的是尽量的减少丢包。</li>
</ol>
<h6 id="适合UDP传输的情况"><a href="#适合UDP传输的情况" class="headerlink" title="适合UDP传输的情况"></a>适合UDP传输的情况</h6><p>允许丢包的场合，比如每秒钟把设备的实时数据发送给管理主机，在管理主机的界面上显示。这种情况即使丢了一次包，也没有太大关系，下次会继续发送的。但是当传输压缩文件*.rar，如果丢了一个包，整个文件就损坏了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/网络（1）/" data-id="cjgnmh0fu000gjpqwsgpui0hz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/线程（3）/" class="article-date">
  <time datetime="2018-04-27T09:04:21.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/线程（3）/">线程（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="线程间的通信机制-信号量"><a href="#线程间的通信机制-信号量" class="headerlink" title="线程间的通信机制-信号量"></a>线程间的通信机制-信号量</h4><h5 id="引例（生产者消费者问题）"><a href="#引例（生产者消费者问题）" class="headerlink" title="引例（生产者消费者问题）"></a>引例（生产者消费者问题）</h5><p><code>Producer</code>: 生产者，每个几秒生成一个物品，并放入缓冲区中。<br><code>Consumer</code>: 消费者，一旦发现缓冲区里有物品即可取走。<br>一个读一个写。<br>如何能保证即时取走？</p>
<h6 id="轮询机制"><a href="#轮询机制" class="headerlink" title="轮询机制"></a>轮询机制</h6><p><code>Consumer</code>线程不知道何时有物品可以取，只是不停地去查询（比如每隔<code>50ms</code>查询一次，以便及时取走）轮询的间隔不能太大，否则缓冲区可能已经堆积如山了。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">OS_Mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">int</span> r = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"放入物品："</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            Msleep(r * <span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"取出物品："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            Msleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上段代码中，生产者和消费者之间是没有联系的，不能保证真正及时的取出来，查询不能太频繁（浪费<code>CPU</code>），不频繁的时候（缓存区满），难以把握，需要设计一个合理的轮询间隔。最好有一个通知机制：生产者把物品放进去之后，通知消费者，消费者接到通知后，再去取物品。这就出现了信号量机制。</p>
<h6 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h6><p>信号量：<code>Semaphore</code>,用于实现线程间的通知机制（和<code>Mutex</code>一样，是一个系统级对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_Semaphore g_sem;</span><br><span class="line">第一个线程: Producer</span><br><span class="line">    g_sem.Post(); //通知</span><br><span class="line">第二个线程: Consumer</span><br><span class="line">    g_sem.Wait(); //等待通知</span><br></pre></td></tr></table></figure></p>
<p><code>osapi</code>库的源代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Semaphore::Init(<span class="keyword">int</span> initial_value)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = <span class="keyword">new</span> OS_Semaphore_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    m_Priv = priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;priv-&gt;hSem, <span class="number">1</span>, initial_value) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> OS_Semaphore::wait()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;priv-&gt;hsem) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OS_Semaphore::Post()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span>;</span><br><span class="line">    sem_post(&amp;priv-&gt;hSem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>信号量的值： <code>0, 1, 2, ..., N, ...</code><br>生产者可以一次放入多个物品，并将信号量的值增加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_sem.Post();//信号量的值加1</span><br><span class="line">g_sem.Wait();//信号量的值减1。如果信号量的值为0，则线程进入等待状态（阻塞），此时不占用cpu。</span><br></pre></td></tr></table></figure></p>
<p>使用信号量机制的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="function">OS_Semaphore <span class="title">g_sem</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//将初始信号量设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">int</span> r = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"放入物品："</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            g_sem.Post();</span><br><span class="line">            Msleep(r * <span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            g_sem.Wait();</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"取出物品："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据实际情况，将信号量的值初始化为<code>0</code>或其他正数，一般情况信号量的初始值由你的实现应用中对应的那个量决定，比如，缓冲区中的物品数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OS_Semaphore g_sem(0);</span><br><span class="line">OS_Semaphore g_sem(10); //已经有了10个量</span><br></pre></td></tr></table></figure></p>
<h6 id="超时等待机制"><a href="#超时等待机制" class="headerlink" title="超时等待机制"></a>超时等待机制</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = g_sem.Wait(<span class="number">1000</span>); <span class="comment">//ms</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="comment">//如果返回值不为0，表明已经超时</span></span><br><span class="line">&#123;<span class="comment">//超时处理&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>osapi</code>中超时处理的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Semaphore::Wait(<span class="keyword">int</span> ms)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    timeval tv_now;</span><br><span class="line">    gettimeofday(&amp;tv_now, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    timespec ts;</span><br><span class="line">    ts.tv_sec = tv_now.tv_sec;</span><br><span class="line">    ts.tv_nsec = tv_now.tv_usec * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ns = ts.tv_nsec + (ms % <span class="number">1000</span>)  * <span class="number">1000000</span>;</span><br><span class="line">    ts.tv_nsec = ns % <span class="number">1000000000</span>;</span><br><span class="line">    ts.tv_sec += ns / <span class="number">1000000000</span>;</span><br><span class="line">    ts.tv_sec += ms / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_timedwait(&amp;priv-&gt;hSem, &amp;ts) != <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/线程（3）/" data-id="cjgnmh0fo000ejpqwsbifuapa" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/线程（2）/" class="article-date">
  <time datetime="2018-04-27T07:07:47.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/线程（2）/">线程（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h4><p>多个线程间可以共享数据：</p>
<ol>
<li>全局对象</li>
<li>堆对象（动态创建的数据）<br>全局对象和堆对象的生命期足够长。</li>
</ol>
<h4 id="数据的完整性"><a href="#数据的完整性" class="headerlink" title="数据的完整性"></a>数据的完整性</h4><p>当一个线程在写，另一个线程在读，由于线程的调度由操作系统进行切换，可能数据处理操作未完成就被切换，所以这时可能会出现问题。数据不完整的根本原因是线程运行时可能会在任意时刻、任意位置被切换。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>当多个线程同时访问一块内存，就有可能会出现数据不完整的问题。此时，需要一种机制来“同步”各个线程对它的访问。（所谓同步，是指协调、安排，使之步调一致）。这种机制就是“互斥锁”机制。在<code>C++`</code>里称为<code>Mutex</code>，<code>Java</code>里称为<code>Lock</code>。</p>
<h6 id="互斥锁的使用"><a href="#互斥锁的使用" class="headerlink" title="互斥锁的使用"></a>互斥锁的使用</h6><p>在访问共享数据之前，先获取锁，在访问完毕后再释放锁。在一个线程获取锁之后，另一个线程的<code>Lock</code>操作会一直等待（阻塞），直到该锁被释放（<code>unlocked</code>）。</p>
<h6 id="互斥锁的使用模式"><a href="#互斥锁的使用模式" class="headerlink" title="互斥锁的使用模式"></a>互斥锁的使用模式</h6><ol>
<li><p>在osapi创建全局对象或堆对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">char</span> g_data[<span class="number">128</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在线程中要访问<code>g_data</code>，必须先获取锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g_mutex.Lock(); <span class="comment">//此函数会阻塞，一直等待拥有锁</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) g_data[i] = i;</span><br><span class="line">g_mutex.Unlock(); <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在<code>osapi</code>中，Lock函数和Unlock函数的相关代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Mutex::Lock()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Mutex_Priv* priv = (OS_Mutex_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_lock(&amp;priv-&gt;hMutex) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">01</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> OS_Mutex::Unlock()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Mutex_Priv* priv = (OS_Mutex_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;priv-&gt;hMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>锁机制是操作系统提供的资源，实际上是操作系统锁对象的封装。</p>
<h6 id="互斥锁的使用原则"><a href="#互斥锁的使用原则" class="headerlink" title="互斥锁的使用原则"></a>互斥锁的使用原则</h6><p>当一个线程占有锁时，应该尽快地完成对共享数据的访问。因为别的线程正在等待。一般策略是直接把数据拷贝一份然后再做处理（处理时间一般比拷贝时间更长）。<br>实例：提供一个<code>generator</code>类和一个<code>checker</code>类，<code>generator</code>将同一个值赋给<code>arr[16]</code>数组中的所有元素。<code>checker</code>检测<code>arr</code>数组中所有元素的值是否相等。不适用互斥锁时会出现数据完整性的问题，添加数据锁后代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = time;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checker</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] != arr[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"check fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，每次<code>generate</code>和<code>check</code>操作的时间为<code>80ms</code>，锁占用的时间也均为<code>80ms</code>，锁占用的时间较长，其他请求这个锁的线程需要等待，这样就违背了使用多线程提升效率的目的。<br>更改的方法是先将数据进行拷贝，再进行处理，在数据生成的时候，先将耗费<code>80ms</code>的生成数据存储在<code>copy</code>数组中，这个过程不需要再占用锁，然后将<code>copy</code>数组的内容复制到<code>arr</code>数组，在复制过程中需要占用锁，但是因为复制的时间很短，所以效率得到了提升，同时保证了数据的完整性。在校验过程中，可以先将<code>arr</code>数组中的值拷贝到<code>copy</code>数组中，这个过程占用锁，然后对<code>copy</code>数组的值进行校验，这个过程不需要再占用锁，这样就达到了优化的效果。优化后的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                copy[i] = time;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="built_in">memcpy</span>(arr, copy, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">16</span>);</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checker</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="built_in">memcpy</span>(copy, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">16</span>);</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(copy[i] != copy[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"check fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="可重入的函数（线程安全的函数）"><a href="#可重入的函数（线程安全的函数）" class="headerlink" title="可重入的函数（线程安全的函数）"></a>可重入的函数（线程安全的函数）</h4><p>可重入（reentrant）的函数，又称为线程安全（thread safe）的函数，是指一个函数，在多个线程里同时调用（并发调用）的时候，<strong>其功能仍然正常</strong>。在并发调用时功能出错的函数称为不可重入的函数（线程不安全）。<br>实例：线程的任务是不断的进行<code>1~n</code>的累加。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        num += i;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = sum(n);</span><br><span class="line">            <span class="keyword">if</span>(res != <span class="number">5050</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实际上上一段代码是线程安全的，但如果将<code>sum</code>函数中的变量<code>num</code>设置为全局变量，则函数变为非线程安全的，因为全局变量在不同的线程之间是可以共享的。所以线程切换时可能会导致全局变量的值不是正确的，原有逻辑受到了影响。</p>
<h6 id="判断是否可重入："><a href="#判断是否可重入：" class="headerlink" title="判断是否可重入："></a>判断是否可重入：</h6><ol>
<li>在单线程的情况下，该函数表现正常，如果单线程出了问题，说明函数写错了。</li>
<li>在多线程并发调用此函数时，如果函数仍然表现正常，则说明该函数是可重入的。</li>
</ol>
<h6 id="很可能不可重入的情况："><a href="#很可能不可重入的情况：" class="headerlink" title="很可能不可重入的情况："></a>很可能不可重入的情况：</h6><ol>
<li>一个全局函数（写在类之外的函数），借助全局对象来实现，并且有写操作，那么就是不可重入的。</li>
<li>一个类的成员函数，它访问并修改了成员变量，那么一般情况下它就是不可重入的。</li>
</ol>
<h6 id="将不可重入转换成可重入的"><a href="#将不可重入转换成可重入的" class="headerlink" title="将不可重入转换成可重入的"></a>将不可重入转换成可重入的</h6><ol>
<li>不借助外部变量，尽量使用本函数内定义的局部变量来实现。或者在本函数动态创建对象，并在退出前销毁对象。没有外部依赖，不操作外部变量。</li>
<li>实在不行的话可以加上互斥锁控制。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/线程（2）/" data-id="cjgnmh0fn000cjpqwm6rk14ab" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/26/线程（1）/" class="article-date">
  <time datetime="2018-04-26T13:09:31.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/26/线程（1）/">线程（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>main</code>函数是主线程，即使没有使用其他的线程，这条主线程也一直存在，主线程退出所有的线程整个程序就都退出了。使用<code>Thread</code>技术创建的线程，它们用于运行并发的任务。普通函数的调用是无法实现并行的任务的。</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>假如只有一个<code>CPU</code>，所有的线程共享这个<code>CPU</code>。</p>
<ol>
<li>每个线程都要自觉的让出<code>CPU</code>，使得其他线程也有机会被运行。可以使用<code>Sleep</code>实现。</li>
<li>操作系统会把时间分割成很细的小片（时间片），让每个线程都会有机会运行几毫秒，轮流运行。（宏观上感觉是线程在并行执行）。</li>
<li>使用<code>Sleep</code>函数让一个线程处于休眠状态，当一个线程休眠时，<code>CPU</code>会供其他线程使用。操作系统会统一进行调度，决定哪个线程被执行。</li>
</ol>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>当<code>Task1.exe</code>被加载到内存中运行时，运行的实例成为一个进程。（可以在任务管理器中查看），<code>Task1.exe</code>称为程序文件，它可以同时被运行多次，每运行一次，一个新的进程就被创建。一个进程中可以创建多个线程，其中至少有一个主线程。由操作系统负责安排调度；决定哪一个线程被运行。不同操作系统遵循同一个原则，尽可能让所有的线程都有机会运行。</p>
<h4 id="调度方法-时间片法："><a href="#调度方法-时间片法：" class="headerlink" title="调度方法 时间片法："></a>调度方法 时间片法：</h4><p>把<code>cpu</code>时间划分为均等的时间片，总体上看各个线程是被轮流运行的。线程切换过程如下：</p>
<ol>
<li>把当前的线程切到后台，进入队列等待。队列可以称为候选队列，表示里面的线程都希望自己被立刻执行。</li>
<li>从队列中取得一个正在排队的线程并运行这个线程。</li>
<li><code>5ms</code>后再次进行切换（时间片为<code>5ms</code>）</li>
</ol>
<p>需要知道</p>
<ol>
<li>使用<code>Sleep</code>函数，可以主动让自己的线程提前让出<code>CPU</code>。</li>
<li><code>Sleep</code>时间到的时候，线程并不是立即执行的，而是进入了候选队列。如果设定了N毫秒，实际间隔的时间会大于N。一般会支持到毫秒量级。</li>
<li>由操作系统决定如何在候选队列里挑选下一个线程。</li>
</ol>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>某些操作系统可能支持线程的优先级，<code>Priority</code>。允许我们再创建线程的时候，指定一下线程的优先级。如果优先级较高，则该线程在运行的时候拥有较高的机会被调度。但是可能不可靠，不是所有的系统都支持，并且可能无法定量。</p>
<h4 id="线程创建与启动"><a href="#线程创建与启动" class="headerlink" title="线程创建与启动"></a>线程创建与启动</h4><p>例如使用<code>osapi</code>库，定义一个Task类，继承于<code>OS_Thread</code>，重写线程主函数<code>Routine()</code>（这是一个虚函数），使用时<code>MyTask task; task.Run();</code>。在多数系统中，线程的创建和启动是一个连续的动作。线程属于系统级资源，可以在“资源管理器”中查看每个进程的线程数。创建线程是操作系统进行的，不能直接调用<code>Routine</code>函数。调用<code>Run</code>函数时，相当于对<code>OS</code>说“请创建一个线程，入口函数为<code>Routine()</code>”，OS则根据程序员的要求，创建一个线程实体来运行，线程的主函数就是<code>Routine()</code>。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">OS_Thread_Proc_Linux</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OS_Thread* thrd = (OS_Thread*) param;</span><br><span class="line">    thrd-&gt;Routine();  <span class="comment">//Routine函数声明virtual int Routine() = 0;</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> OS_Thread::Run()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Thread_Priv* priv = <span class="keyword">new</span> OS_Thread_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    m_Priv = priv;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;priv-&gt;hThread, <span class="literal">NULL</span>, OS_Thread_Proc_Linux, <span class="keyword">this</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>Run</code>函数后，主要通过调用<code>pthread_create</code>函数创建线程，实际上线程主函数是<code>OS_Thread_Proc_Linux</code>，然后在这个函数中由调用了程序员重载的纯虚函数<code>Routine</code>。</p>
<h6 id="两种语境"><a href="#两种语境" class="headerlink" title="两种语境"></a>两种语境</h6><ol>
<li><code>OS_Thread:</code>它是一个<code>C++</code>类/对象，封装了线程相关数据和操作。</li>
<li>线程实体：由操作系统创建的实体，通常说的线程指的是线程实体，是一个运行时的概念。<h6 id="线程是有限的资源"><a href="#线程是有限的资源" class="headerlink" title="线程是有限的资源"></a>线程是有限的资源</h6>线程是系统级资源，线程的切换和调度也是有成本的，所以一个进程中的最大线程数是有限制的，一般为几千到几万。在工程实践中，一般线程数最多为几十个。</li>
</ol>
<h4 id="线程的停止和回收"><a href="#线程的停止和回收" class="headerlink" title="线程的停止和回收"></a>线程的停止和回收</h4><h6 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h6><p>在<code>osapi</code>中，当<code>return</code>语句被执行时，表示该线程正常退出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"do something \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//线程主函数退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>return</code>语句被执行、<code>Routine()</code>函数返回，线程退出。</p>
<h6 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h6><p>当主线程（主程序）退出的时候，所有的线程都会被立即终止，即使有线程正在运行。这种终止时不正常的，有可能会造成数据的不完整。<br>例如主函数中添加了<code>getchar</code>函数，当没有<code>getchar</code>函数时，主线程会一直执行，执行完毕后立即退出，所以其他线程也可能会异常终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Buddhist task1;</span><br><span class="line">    task1.Run(); <span class="comment">//线程1</span></span><br><span class="line">    Confucian task2;</span><br><span class="line">    task2.Run(); <span class="comment">//线程2</span></span><br><span class="line">    getchar(); <span class="comment">//输入回车主线程终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="线程的回收"><a href="#线程的回收" class="headerlink" title="线程的回收"></a>线程的回收</h6><p>使用<code>OS_Thread::Join(&amp;task);</code>等待线程的退出，函数实现如下，实际上是对pthread_join函数进行了封装。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OS_Thread::Join(OS_Thread* thrd)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Thread_Priv* priv = (OS_Thread_Priv*) thrd-&gt;m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(priv)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_join(priv-&gt;hThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        thrd-&gt;m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Join</code>函数的作用：</p>
<ol>
<li>等待目标线程的退出，如果目标线程尚未退出，则会一直等待，直到其退出为止。</li>
<li>回收这个线程的相关系统资源（线程的个数是受限的）。</li>
</ol>
<p><code>Join</code>的调用：当一个线程A要退出时，由另一个线程调用来回收线程A。需要注意的是：<code>Join</code>不能回收自己。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Join(<span class="keyword">this</span>); <span class="comment">//出错的，不能自己join自己</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以由主线程或者任何一个其他线程执行<code>Join</code>。<code>Join</code>的位置：不能只看字面上的位置，而是要从运行的角度来看待问题，例如如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buddhist</span>:</span> <span class="keyword">public</span> OS_Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_quitfalg = <span class="literal">false</span>;</span><br><span class="line">        Run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_quitfalg = <span class="literal">true</span>;</span><br><span class="line">        Join(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_quitfalg;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; !m_quitfalg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ma mi ma mi hong..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            OS_Thread::Sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"善后工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，<code>Join</code>函数位于创建线程类的<code>stop</code>函数中，并且将<code>this</code>作为参数，但实际上这种写法是正确的，因为<code>stop</code>函数是在主函数即主线程中调用，虽然代码中使用<code>Join(this)</code>，但实际上并不是自己等待自己。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/26/线程（1）/" data-id="cjgnmh0fk000ajpqwqa1iprv4" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Building-C-Projects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/Building-C-Projects/" class="article-date">
  <time datetime="2018-04-25T13:59:56.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/Building-C-Projects/">Building C Projects</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要对构建C项目的过程进行描述，主要参考这篇博客(<a href="http://nethack4.org/blog/building-c.html" target="_blank" rel="noopener">http://nethack4.org/blog/building-c.html</a>)<br></p>
<ol>
<li>配置（Configuration）</li>
<li>标准目录检测（Standard directory detection）</li>
<li>源文件依赖计算（Source file dependency calculation）</li>
<li>头文件定位（Head file location）</li>
<li>头文件预编译（Header precomplition）</li>
<li>预处理（Preprocessing）</li>
<li>编译和汇编（Compilation and assembly）</li>
<li>目标文件依赖计算（Object file dependency calculation）</li>
<li>链接（linking）</li>
<li>安装（Installation）</li>
<li>资源链接（Resource linking）</li>
<li>包生成（Package generation）</li>
<li>动态链接（Dynamic linking）<br>主要过程如上所示，实际上C不一定要按照上述步骤构建。如果按部就班的讲解很难描述清楚，因为有些步骤是接下来一些步骤的准备，很容易让人迷惑，所以从第6部开始慢慢延伸。</li>
</ol>
<h4 id="6：-Preprocessing"><a href="#6：-Preprocessing" class="headerlink" title="6： Preprocessing"></a>6： Preprocessing</h4><p>使用下面的c程序作为示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Hello, world!\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们首先要关注第一行<code>#include&lt;stdio.h&gt;</code>，一个常见的误解是这行程序与一些库有关系，它将fputs的定义与库中的程序联系在一起。实际上这行代码只是告诉编译器fputs和stdout所拥有的类型，等同于下面代码（省略了很多不相关的代码）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, FILE *)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Hello, world!\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上与链接没有关系，stdio.h只是一些类型、函数、变量和宏定义的声明列表。C标准对于编译器如何实现这些定义没有任何限制，但实际上，类似stdio.h这样的头文件几乎都由轻量扩展的C程序实现。在这个例子中FILE是一个不完全的类型，extern意味着只是一个声明，不一定包含函数或变量的定义。<br><br>预处理同时会移除源文件中的注释。如今，预处理阶段经常与编译阶段同时进行，但是预处理阶段也是可以单独进行的，使用-E指令进行预处理操作，预处理后的文件后缀为.i。</p>
<h4 id="5：Header-precomplition"><a href="#5：Header-precomplition" class="headerlink" title="5：Header precomplition"></a>5：Header precomplition</h4><p>不同的源码文件可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译，为了节省时间，并且如果头文件的声明有错误，每个包含该头文件的程序都会出现相同错误，无论是否与这个错误相关联，编译器会在编译源码之前，先编译头文件。这保证头文件只需要编译一次，不过并不是头文件的所有内容都会被预编译。例如用来声明宏的#define指令，就不会被预编译。</p>
<h4 id="4：Header-file-location"><a href="#4：Header-file-location" class="headerlink" title="4：Header file location"></a>4：Header file location</h4><p>为了能够包含头文件，必须能够在文件系统中找到，大多数预处理使用的方法都很简单，可以使用一个硬编码的目录列表，用户可以将其添加到目录中，预处理时会按照顺序进行扫描，知道找到正在查找的文件。<br><br>当项目较大时，也可以通过扫描经过适当命名的头文件资源树，然后通过比较路径（根据目录结构采用最接近的匹配头文件）来计算出哪个头文件是预期的。当使用分层构建时，项目的不同部分必须放置在不同的目录中，采用这种方法使较为明智的。</p>
<h4 id="3：Source-file-dependency-calculation"><a href="#3：Source-file-dependency-calculation" class="headerlink" title="3：Source file dependency calculation"></a>3：Source file dependency calculation</h4><p>对于大型项目，源码文件之间往往存在着依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。<br><br>（1）只有在B文件编译完成后，才开始编译A文件。<br><br>（2）当B文件发生变化时，A文件才能被重新编译。<br><br>如今依赖自动化的方法主要通过预处理器对包含的每个头文件进行报告（大多数可以直接生成makefile片段），这会引发chicken-and-egg问题（只有通过编译才能计算出依赖，只有获取依赖才能顺利编译）。标准的方法是首先在没有依赖的情况下进行构建，这满足了第一点要求，但是第二点并不满足。<br>编译顺序保存在makefile文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须先运行的原因。在确定依赖关系的同时，编译器也确定了编译时会用到哪些头文件。</p>
<h6 id="2：Standard-directory-detection"><a href="#2：Standard-directory-detection" class="headerlink" title="2：Standard directory detection"></a>2：Standard directory detection</h6><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。<br><br>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p>
<h6 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1: Configuration"></a>1: Configuration</h6><p>在编译器开始工作之前，需要知道当前系统的环境，比如标准库在哪里，软件安装在哪里，需要安装哪些组件等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的代码。这个确定编译参数的步骤，就叫做配置（Configuration）。<br><br>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。<br><br>configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/www --with-mysql</span><br></pre></td></tr></table></figure></p>
<p>上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。</p>
<h4 id="7-Compilation-and-assembly"><a href="#7-Compilation-and-assembly" class="headerlink" title="7: Compilation and assembly"></a>7: Compilation and assembly</h4><p>预处理阶段输出的是轻微扩展的C代码，目标文件（链接器的输入）则是轻微修改的机器码，与处理器实际运行的机器代码的区别在于它充满了与链接器相关的指令以及与处理器相关的指令。<br><br>有两种方法可以将c代码转换成机器码。一种方法是直接进行转换，另外一种是通过汇编代码，即通过编译和汇编两个过程，汇编代码可以通过C代码执行-S指令获得，也可以通过对目标文件进行反汇编获得。上述示例的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;t.c&quot;</span><br><span class="line">.section    .rodata             Contents of section .rodata:</span><br><span class="line">.LC0:</span><br><span class="line">.string &quot;Hello, world!\n&quot;       Hello, world!..</span><br><span class="line">.text                           Disassembly of section .text:</span><br><span class="line">.globl  main</span><br><span class="line">.type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq   %rbp                    push   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp              mov    %rsp,%rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">movq    stdout(%rip), %rax      mov    0x0(%rip),%rax</span><br><span class="line">movq    %rax, %rcx              mov    %rax,%rcx</span><br><span class="line">movl    $14, %edx               mov    $0xe,%edx</span><br><span class="line">movl    $1, %esi                mov    $0x1,%esi</span><br><span class="line">movl    $.LC0, %edi             mov    $0x0,%edi</span><br><span class="line">call    fwrite                  callq  22 &lt;main+0x22&gt;</span><br><span class="line">movl    $0, %eax                mov    $0x0,%eax</span><br><span class="line">popq    %rbp                    pop    %rbp</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.size   main, .-main</span><br><span class="line">.ident  &quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot;</span><br><span class="line">.section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码包括一些与链接器相关的信息，有些在机器码中是不存在的。汇编代码中有很多段来告诉链接器不同数据存储的位置，main函数从.text开始，.rodate代表只读，.cfi_代表生成栈展开信息，例如可以通过objdump -d test.o获得反汇编代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format elf64-x86-64          </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:                  </span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:                        </span><br><span class="line">   0:   55                      push   %rbp      </span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp  </span><br><span class="line">   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax</span><br><span class="line">   b:   48 89 c1                mov    %rax,%rcx</span><br><span class="line">   e:   ba 0e 00 00 00          mov    $0xe,%edx</span><br><span class="line">  13:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  18:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  1d:   e8 00 00 00 00          callq  22 &lt;main+0x22&gt;</span><br><span class="line">  22:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  27:   5d                      pop    %rbp</span><br><span class="line">  28:   c3                      retq</span><br></pre></td></tr></table></figure></p>
<p>使用objdump -x命令可以生成symbol table，可以对符号表中的值进行定位。使用-S命令进行编译，使用-c进行汇编。</p>
<h4 id="8-Object-file-dependency-calculation"><a href="#8-Object-file-dependency-calculation" class="headerlink" title="8: Object file dependency calculation"></a>8: Object file dependency calculation</h4><p>一旦生成了目标文件，下一步要考虑的是如何将这些目标文件组合在一起生成可执行文件。为了生成可执行文件，需要获得满足依赖关系的目标文件和相关库的列表，在这些目标文件中出现的任何未定义的符号都需要被其他的目标文件所定义，同时也需要提供开始运行的入口点。<br><br>对于每个主函数都有一个可执行文件，可以通过递归的查找未定义符号所依赖的库或目标文件。</p>
<h4 id="9-Linking"><a href="#9-Linking" class="headerlink" title="9: Linking"></a>9: Linking</h4><p>一旦了解需要组合哪些目标文件来生成可执行文件，下一步通过链接器生成可执行文件，观察第七步生成的汇编代码，会发现其中引用了stdout函数和fwrite函数。也就是说程序要正常运行，还需要stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。<br><br>编译器下一步工作是把外部函数的代码（通常后缀名为.lib和.a的文件），添加到可执行文件中，其中涉及到内存地址的定位等。这种通过拷贝，将外部函数添加到可执行文件的方式叫做静态链接。后文还会提到动态链接。<br>make命令的作用是从第五步到这一步结束。</p>
<h4 id="10-Installation"><a href="#10-Installation" class="headerlink" title="10: Installation"></a>10: Installation</h4><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。表面上这个过程很简单，就是将可执行文件（连带相关的数据文件）拷贝过去即可。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就成为“安装”。</p>
<h4 id="11-Resource-Linking"><a href="#11-Resource-Linking" class="headerlink" title="11: Resource Linking"></a>11: Resource Linking</h4><p>资源链接通常和安装过程同时进行，正常的方法是手动编写构建规则以执行相关步骤。在windows上，VS在链接后立即执行资源链接。</p>
<h4 id="12-Package-generation"><a href="#12-Package-generation" class="headerlink" title="12: Package generation"></a>12: Package generation</h4><p>到这里，源码编译的过程就基本完成了。但事实上，如果只有源码可以交给用户是很不友好的。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，能够将上一步生成的可执行文件做成可以分发的安装包。所以编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关数据文件）以某种目录结构保存成压缩文件包交给用户。</p>
<h4 id="13-Dynamic-Linking"><a href="#13-Dynamic-Linking" class="headerlink" title="13: Dynamic Linking"></a>13: Dynamic Linking</h4><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。<br><br>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。<br><br>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/Building-C-Projects/" data-id="cjgnmh0ea0000jpqwboheotmb" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试复习（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/面试复习（2）/" class="article-date">
  <time datetime="2018-04-24T16:56:04.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/面试复习（2）/">面试复习（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-两个栈模拟一个队列（模板代码）"><a href="#1-两个栈模拟一个队列（模板代码）" class="headerlink" title="1.两个栈模拟一个队列（模板代码）"></a>1.两个栈模拟一个队列（模板代码）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    if(stack2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        while(!stack1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(stack2.empty())</span><br><span class="line">        throw new exception(&quot;queue is empty&quot;);</span><br><span class="line">    tmp = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-二进制中1的个数"><a href="#2-二进制中1的个数" class="headerlink" title="2.二进制中1的个数"></a>2.二进制中1的个数</h4><p>最重要的公式：将一个整数和它减一的结果做位与运算，相当于把最右边的1变成了0。所以伪代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n &amp; (n - 1);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-数值的整数次方"><a href="#3-数值的整数次方" class="headerlink" title="3.数值的整数次方"></a>3.数值的整数次方</h4><p>实现函数double Power(double base, int exponent)，需要注意的有以下几点：<br><br>1.当指数为负数时，先求绝对值，计算后求倒数。<br><br>2.当底数为0且指数为负数时，会出现对0求倒数，可以通过返回值，全局代码或异常来处理错误。<br><br>3.0的0次方时没有意义的，所以要考虑这个边界值。<br><br>4.判断底数是否为0时，不能直接写base = 0，因为在计算机内表示小数时会有误差，判断两个小数是否相等时，只能判断它们的差得绝对值是否在很小的范围内。<br><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">bool g_InvalidInput = false;</span><br><span class="line">bool equal(double num1, double num2)</span><br><span class="line">&#123;</span><br><span class="line">    if(num1 - num2 &lt; 0.0000001 &amp;&amp; num1 - num2 &gt; -0.0000001)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double PowerWithUnsignedExponent(double base, unsigned int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    if(exponent == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return base;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(exponent == 0)</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1);</span><br><span class="line">    result *= result;</span><br><span class="line">    if(exponent % 2 == 1)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    g_InvalidInput = false;</span><br><span class="line">    int absExponent = exponent;</span><br><span class="line">    if(equal(base, 0.0) &amp;&amp; exponent &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = true;</span><br><span class="line">        return 0.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned int absExponent = unsigned int(exponent);</span><br><span class="line">    if(exponent &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        absExponent = (unsigned int)()-exponent);</span><br><span class="line">    &#125;</span><br><span class="line">    double res = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">    if(exponent &lt; 0)</span><br><span class="line">        res = 1.0 / res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-在O-1-时间内删除链表节点"><a href="#4-在O-1-时间内删除链表节点" class="headerlink" title="4. 在O(1)时间内删除链表节点"></a>4. 在O(1)时间内删除链表节点</h4><p>通常方法是从头查找，这是因为我们需要得到将被删除的节点的前一个节点，实际上可以得到删除节点的下一个节点，将下一个节点的内容复制到需要删除的节点，再将下一个节点删除即可。如果删除的节点位于链表的尾部则需要继续从头开始删除。时间复杂度为[(n-1)O(1) + O(n)]/n，结果还是O(1)。相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void DeleteHead(ListNode** pListHead, ListNode* pToBeDeleted)</span><br><span class="line">&#123;</span><br><span class="line">    if(!pListHead || !pToBeDeleted)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if(pToBeDeleted-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* tmp = pToBeDeleted-&gt;next;</span><br><span class="line">        pToBeDeleted-&gt;value = tmp-&gt;val;</span><br><span class="line">        pToBeDeleted-&gt;next = tmp-&gt;next;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = NULL;</span><br><span class="line">        *pListHead = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* tmp = *pListHead;</span><br><span class="line">        while(tmp-&gt;next != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = NULL;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/面试复习（2）/" data-id="cjgnmh0g0000ojpqwjhiymkxl" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/复习/">复习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LLVM学习（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/22/LLVM学习（3）/" class="article-date">
  <time datetime="2018-04-21T16:37:24.000Z" itemprop="datePublished">2018-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/22/LLVM学习（3）/">LLVM学习（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇通过简单的HelloWorld演示了在LLVM中编写Pass的基本方法，本文将介绍一些其他的pass实例,创建以及修改pass文件以及build llvm等内容不再重复。<br>首先在LLVM中，程序的基本单位是模块。函数是模块的基本组成单位，一个模块由一个或多个函数组成。Basic Block又是函数的基本组成单位，所以一个Function由一个或多个Basic block组成。指令是Basic Block的基本组成单位，一个Basic Block由一个或多个指令组成。<br><br>Module—&gt;Function—&gt;Basic Block—&gt;instruction</p>
<h5 id="利用pass在函数中遍历Basic-Block"><a href="#利用pass在函数中遍历Basic-Block" class="headerlink" title="利用pass在函数中遍历Basic Block"></a>利用pass在函数中遍历Basic Block</h5><p>本文中直接在HelloWorld.cpp中进行修改，内容修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/ADT/Statistic.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Function.h&quot;</span><br><span class="line">#include &quot;llvm/Pass.h&quot;</span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">#define DEBUG_TYPE &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, &quot;Counts number of functions greeted&quot;);</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  struct HelloWorld : public FunctionPass &#123;</span><br><span class="line">    static char ID; // Pass identification, replacement for typeid</span><br><span class="line">    HelloWorld() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">      errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">      errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">      for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">      &#123;   </span><br><span class="line">        errs() &lt;&lt; &quot;BasicBlock name = &quot; &lt;&lt; bb-&gt;getName() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">        for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            outs() &lt;&lt; &quot; &quot; &lt;&lt; *i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char HelloWorld::ID = 0;</span><br><span class="line">static RegisterPass&lt;HelloWorld&gt; X(&quot;helloWorld&quot;, &quot;Hello World Pass&quot;);</span><br></pre></td></tr></table></figure></p>
<p>代码首先打印每个函数的名称，接下来使用迭代器对每个函数中的Basic Block进行遍历，并且输出每个Basic Block的名称和大小。然后对每个Basic Block中的指令进行遍历。输出每条具体指令。接下来创建测试文件cul.cpp，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mul(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; add(1, 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mul(5, 6) &lt;&lt; endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来使用以下命令执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ cul.cpp -O0 -S -emit-llvm -o cul.ll</span><br><span class="line">opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld cul.ll</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 3</span><br><span class="line"></span><br><span class="line">   call void @_ZNSt8ios_base4InitC1Ev(%&quot;class.std::ios_base::Init&quot;* @_ZStL8__ioinit)</span><br><span class="line">   %1 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%&quot;class.std::ios_base::Init&quot;*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%&quot;class.std::ios_base::Init&quot;, %&quot;class.std::ios_base::Init&quot;* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #3</span><br><span class="line">   ret void</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 8</span><br><span class="line"></span><br><span class="line">   %3 = alloca i32, align 4</span><br><span class="line">   %4 = alloca i32, align 4</span><br><span class="line">   store i32 %0, i32* %3, align 4</span><br><span class="line">   store i32 %1, i32* %4, align 4</span><br><span class="line">   %5 = load i32, i32* %3, align 4</span><br><span class="line">   %6 = load i32, i32* %4, align 4</span><br><span class="line">   %7 = add nsw i32 %5, %6</span><br><span class="line">   ret i32 %7</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 8</span><br><span class="line"></span><br><span class="line">   %3 = alloca i32, align 4</span><br><span class="line">   %4 = alloca i32, align 4</span><br><span class="line">   store i32 %0, i32* %3, align 4</span><br><span class="line">   store i32 %1, i32* %4, align 4</span><br><span class="line">   %5 = load i32, i32* %3, align 4</span><br><span class="line">   %6 = load i32, i32* %4, align 4</span><br><span class="line">   %7 = mul nsw i32 %5, %6</span><br><span class="line">   ret i32 %7</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 9</span><br><span class="line"></span><br><span class="line">   %1 = alloca i32, align 4</span><br><span class="line">   store i32 0, i32* %1, align 4</span><br><span class="line">   %2 = call i32 @_Z3addii(i32 1, i32 2)</span><br><span class="line">   %3 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEi(%&quot;class.std::basic_ostream&quot;* @_ZSt4cout, i32 %2)</span><br><span class="line">   %4 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEPFRSoS_E(%&quot;class.std::basic_ostream&quot;* %3, %&quot;class.std::basic_ostream&quot;* (%&quot;class.std::basic_ostream&quot;*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)</span><br><span class="line">   %5 = call i32 @_Z3mulii(i32 5, i32 6)</span><br><span class="line">   %6 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEi(%&quot;class.std::basic_ostream&quot;* @_ZSt4cout, i32 %5)</span><br><span class="line">   %7 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEPFRSoS_E(%&quot;class.std::basic_ostream&quot;* %6, %&quot;class.std::basic_ostream&quot;* (%&quot;class.std::basic_ostream&quot;*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)</span><br><span class="line">   ret i32 0</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 2</span><br><span class="line"></span><br><span class="line">   call void @__cxx_global_var_init()</span><br><span class="line">   ret void</span><br></pre></td></tr></table></figure>
<p>由结果可知，共执行了五个函数，每个函数有一个基本块（Basic Block），每个基本块的size即为基本块中指令的数量。</p>
<h5 id="利用pass对程序中的操作码进行计数"><a href="#利用pass对程序中的操作码进行计数" class="headerlink" title="利用pass对程序中的操作码进行计数"></a>利用pass对程序中的操作码进行计数</h5><p>代码中主要使用map对每个函数中出现的操作码进行统计，对每一条指令可以使用getOpcodeName获取操作码。主要代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">  std::map&lt;std::string, int&gt; m;</span><br><span class="line">  std::map&lt;std::string, int&gt;::iterator iter;</span><br><span class="line">  errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">  errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        std::string tmpName = i-&gt;getOpcodeName();</span><br><span class="line">        if(m.find(tmpName) == m.end())</span><br><span class="line">        &#123;   </span><br><span class="line">            m[tmpName] = 1;</span><br><span class="line">        &#125;   </span><br><span class="line">        else</span><br><span class="line">            m[tmpName]++;</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line">  for(iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; &quot;\n&quot;;</span><br><span class="line">  &#125;   </span><br><span class="line">  errs() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">  m.clear();</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用同样命令执行后结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock size = 3</span><br><span class="line">call 2</span><br><span class="line">ret 1</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">add 1</span><br><span class="line">alloca 2</span><br><span class="line">load 2</span><br><span class="line">ret 1</span><br><span class="line">store 2</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">alloca 2</span><br><span class="line">load 2</span><br><span class="line">mul 1</span><br><span class="line">ret 1</span><br><span class="line">store 2</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock size = 9</span><br><span class="line">alloca 1</span><br><span class="line">call 6</span><br><span class="line">ret 1</span><br><span class="line">store 1</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock size = 2</span><br><span class="line">call 1</span><br><span class="line">ret 1</span><br></pre></td></tr></table></figure></p>
<p>通过结果可知，每个基本块的大小与所有操作码数量之和是相同的。</p>
<h5 id="Def-Use-and-Use-Def"><a href="#Def-Use-and-Use-Def" class="headerlink" title="Def-Use and Use-Def"></a>Def-Use and Use-Def</h5><p>Def-Use实现的功能是找出所有使用了某一个def（或称value）的instruction。Use-Def实现的功能是针对某一个instruction输出其所使用的所有operands（操作数）.</p>
<blockquote>
<p><strong>Def-Use:</strong> Frequently, we might have an instance of the Value Class and we want to determine which Users use the Value. The list of all Users of a particular Value is called a def-use chain.<br>let’s say we have a Function* named F to a particular function foo. Finding all of the instructions that use foo is as simple as iterating over the def-use chain of F:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function *F = ...;    </span><br><span class="line">for (User *U : F-&gt;users()) &#123;  </span><br><span class="line">  if (Instruction *Inst = dyn_cast&lt;Instruction&gt;(U)) &#123;  </span><br><span class="line">    errs() &lt;&lt; &quot;F is used in instruction:\n&quot;;  </span><br><span class="line">    errs() &lt;&lt; *Inst &lt;&lt; &quot;\n&quot;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中使用到了动态类型转换dyn_cast&lt;&gt;,用来检测操作数是否是特定的类型，如果是的话则返回指针（不能使用引用），否则的话就返回空指针，dyn_cast与c++中的dynamic_cast类似，与c++不同的是dynamic_cast只能在拥有虚函数表的类中使用：通常dyn_cast运算符在if语句或其他控制语句中使用，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (auto *AI = dyn_cast&lt;AllocationInst&gt;(Val)) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种形式的语句将isa&lt;&gt;和cast&lt;&gt;结合在一起，较为方便。isa&lt;&gt;类似于java的”instanceof”, cast&lt;&gt;将一个指针或引用从基类转换为派生类。最终代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">  errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">  errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        Instruction* inst = dyn_cast&lt;Instruction&gt;(i);</span><br><span class="line">        if(inst-&gt;getOpcode() == Instruction::Add || inst-&gt;getOpcode() == Instruction::Mul)</span><br><span class="line">        &#123;   </span><br><span class="line">            for(User *U: inst-&gt;users())</span><br><span class="line">            &#123;   </span><br><span class="line">                if(Instruction *Inst = dyn_cast&lt;Instruction&gt;(U))</span><br><span class="line">                &#123;   </span><br><span class="line">                    outs() &lt;&lt; &quot;Opcode &quot; &lt;&lt; inst-&gt;getOpcodeName() &lt;&lt; &quot; used in ::&quot;;</span><br><span class="line">                    outs() &lt;&lt; *Inst &lt;&lt; &quot;\n&quot;;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用之前的测试c++代码，输出结果如下,由上面的.ll程序可知，首先在函数中使用add和mul指令，然后在下一行ret指令中使用到了运算生成的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze84k9sdnqv3f0fuhpwz LLVMCODE]# opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld cul.ll</span><br><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock size = 3</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">Opcode add used in ::  ret i32 %7</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">Opcode mul used in ::  ret i32 %7</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock size = 9</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock size = 2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Use-Def</strong> Alternatively, it’s common to have an instance of the User Class and need to know what Values are used by it. The list of all Values used by a User is known as a use-def chain. Instances of class Instruction are common User s, so we might want to iterate over all of the values that a particular instruction uses (that is, the operands of the particular Instruction):</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instruction *pi = ...;  </span><br><span class="line"></span><br><span class="line">for (Use &amp;U : pi-&gt;operands()) &#123;  </span><br><span class="line">  Value *v = U.get();  </span><br><span class="line">  // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">  errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">  errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        Instruction* inst = dyn_cast&lt;Instruction&gt;(i);</span><br><span class="line">        if(inst-&gt;getOpcode() == Instruction::Add || inst-&gt;getOpcode() == Instruction::Mul)</span><br><span class="line">        &#123;   </span><br><span class="line">            for(Use &amp;U: inst-&gt;operands())</span><br><span class="line">            &#123;   </span><br><span class="line">                Value *v = U.get();</span><br><span class="line">                outs() &lt;&lt; *v &lt;&lt; &quot;\n&quot;;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用之前的测试c++代码，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze84k9sdnqv3f0fuhpwz LLVMCODE]# opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld cul.ll</span><br><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock size = 3</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">  %5 = load i32, i32* %3, align 4</span><br><span class="line">  %6 = load i32, i32* %4, align 4</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">  %5 = load i32, i32* %3, align 4</span><br><span class="line">  %6 = load i32, i32* %4, align 4</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock size = 9</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock size = 2</span><br></pre></td></tr></table></figure></p>
<p>由上输出结果可知，分别输出了add指令和mul指令的两个操作数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/22/LLVM学习（3）/" data-id="cjgnmh0f60006jpqwcueqjzzm" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM/">LLVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LLVM学习（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/LLVM学习（2）/" class="article-date">
  <time datetime="2018-04-20T03:15:52.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/LLVM学习（2）/">LLVM学习（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LLVM的pass框架是LLVM系统的重要部分。LLVM的优化和转换工作就是由多个pass来一起完成的的。类似流水线操作一样，每个pass完成特定的优化工作。所有的pass大致可以分成两类：分析和转换分析类的pass以提供信息为主，转换类的会修改中间代码。</p>
<p>假如LLVM的安装目录为/root/CL/llvm，那么首先在路径/root/CL/llvm/lib/Transforms中创建一个子文件夹，例如名字为HelloWorld。然后在此文件夹下创建三个文件，可以从其他文件夹复制过来。然后需要修改上层目录（Transforms）中的CMakeLists.txt：需要修改三次文件名，修改为HelloWorld，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if( NOT LLVM_REQUIRES_RTTI )</span><br><span class="line">  if( NOT LLVM_REQUIRES_EH )</span><br><span class="line">    set(LLVM_EXPORTED_SYMBOL_FILE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/HelloWorld.exports)</span><br><span class="line">  endif()</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if(WIN32 OR CYGWIN)</span><br><span class="line">  set(LLVM_LINK_COMPONENTS Core Support)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">add_llvm_loadable_module( LLVMHelloWorld</span><br><span class="line">  HelloWorld.cpp</span><br><span class="line"></span><br><span class="line">  DEPENDS</span><br><span class="line">  intrinsics_gen</span><br><span class="line">  PLUGIN_TOOL</span><br><span class="line">  opt</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>上述build script中的如下部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_loadable_module( LLVMHelloWorld</span><br><span class="line">  HelloWorld.cpp  </span><br><span class="line"></span><br><span class="line">  PLUGIN_TOOL  </span><br><span class="line">  opt  </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这种写法指定当前目录中的HelloWorld.cpp文件编译并链接到共享对象../lib/LLVMHelloWorld.so中，该选项可以通过opt选项工具进行动态加载。如果操作系统使用.so之外的后缀（windows或mac）,则将使用相应的扩展名。</p>
<p>接下来是pass文件中的具体内容，这个pass文件实际上就是一个.cpp文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/IR/Function.h&quot;  </span><br><span class="line">#include &quot;llvm/Pass.h&quot;  </span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;  </span><br><span class="line"></span><br><span class="line">using namespace llvm;  </span><br><span class="line"></span><br><span class="line">#define DEBUG_TYPE &quot;hello&quot;  </span><br><span class="line"></span><br><span class="line">namespace &#123;  </span><br><span class="line">  struct HelloWorld : public FunctionPass &#123;  </span><br><span class="line">    static char ID; // Pass identification, replacement for typeid  </span><br><span class="line">    HelloWorld() : FunctionPass(ID) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;  </span><br><span class="line">        errs() &lt;&lt; &quot;HelloWorld: &quot;;  </span><br><span class="line">        errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">char MyHello::ID = 0;  </span><br><span class="line">static RegisterPass&lt;HelloWorld&gt; X(&quot;helloWorld&quot;, &quot;Hello World Pass&quot;);</span><br></pre></td></tr></table></figure></p>
<p>代码1~3行首先需要引入用到的LLVM头文件，之后DEBUG_TYPE是LLVM用来统计该pass被呼叫的次数或者使用DEBUG输出出错信息时使用的。引用llvm命名空间，这不是好的习惯，但是较为方便。<br><br>使用匿名namespace，避免与export中的symbol冲突，其中HelloWorld继承FunctionPass，代表HelloWorld Pass的输入时以Function为单位。以下代码是重中之重,LLVM会以Function为单位作为参数传递，将每个Function的名称打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;  </span><br><span class="line">    errs() &lt;&lt; &quot;HelloWorld: &quot;;  </span><br><span class="line">    errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的Function pass独立的执行每一个函数。实现一个Function pass通常很简单，Function pass可能会重载三个虚方法（例如runOnFunction）。所有这些方法如果修改程序则返回true，否则返回false。</p>
<p>接下来需要build LLVM，进入/root/CL/build目录中，直接make即可。在自己的环境下不到一分钟就可以完成。出现下图时，表示已经make完成，这时在/root/CL/build/lib中出现LLVMHelloWorld.so文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[ 95%] Built target llvm-opt-report</span><br><span class="line">[ 96%] Built target llvm-pdbutil</span><br><span class="line">[ 96%] Built target RcTableGen</span><br><span class="line">[ 96%] Built target llvm-rc</span><br><span class="line">[ 96%] Built target llvm-readobj</span><br><span class="line">[ 96%] Built target llvm-readelf</span><br><span class="line">[ 96%] Built target llvm-rtdyld</span><br><span class="line">[ 96%] Built target llvm-size</span><br><span class="line">[ 96%] Built target llvm-special-case-list-fuzzer</span><br><span class="line">[ 96%] Built target llvm-split</span><br><span class="line">[ 96%] Built target llvm-stress</span><br><span class="line">[ 96%] Built target llvm-strings</span><br><span class="line">[ 96%] Built target llvm-symbolizer</span><br><span class="line">[ 98%] Built target llvm-xray</span><br><span class="line">[ 98%] Built target obj2yaml</span><br><span class="line">[ 98%] Built target opt</span><br><span class="line">[ 98%] Built target sancov</span><br><span class="line">[ 98%] Built target sanstats</span><br><span class="line">[ 98%] Built target verify-uselistorder</span><br><span class="line">[100%] Built target yaml2obj</span><br><span class="line">[100%] Built target SecondLib</span><br><span class="line">[100%] Built target PipSqueak</span><br><span class="line">[100%] Built target DynamicLibraryLib</span><br><span class="line">[100%] Built target gtest_main</span><br></pre></td></tr></table></figure></p>
<p>然后可以在期望位置建立新的测试文件，例如cul.cpp内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sub(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mul(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int divi(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用clang++ cul.cpp -O3 -S -emit-llvm -o cul.ll命令进行编译，生成.ll文件。然后执行pass，方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld  cul.ll</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下,由此可见pass的作用是逐个的在提示符”Hello”后输出程序中函数的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze84k9sdnqv3f0fuhpwz LLVMCODE]# opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld  cul.ll</span><br><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Hello: _Z3addii</span><br><span class="line">Hello: _Z3subii</span><br><span class="line">Hello: _Z3mulii</span><br><span class="line">Hello: _Z4diviii</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/LLVM学习（2）/" data-id="cjgnmh0f50005jpqw5m6ed3wb" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM/">LLVM</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HSI/">HSI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM/">LLVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复习/">复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HSI/" style="font-size: 10px;">HSI</a> <a href="/tags/LLVM/" style="font-size: 20px;">LLVM</a> <a href="/tags/复习/" style="font-size: 15px;">复习</a> <a href="/tags/线程/" style="font-size: 20px;">线程</a> <a href="/tags/网络/" style="font-size: 20px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/01/网络（3）/">网络（3）</a>
          </li>
        
          <li>
            <a href="/2018/04/30/网络（2）/">网络（2）</a>
          </li>
        
          <li>
            <a href="/2018/04/27/网络（1）/">网络（1）</a>
          </li>
        
          <li>
            <a href="/2018/04/27/线程（3）/">线程（3）</a>
          </li>
        
          <li>
            <a href="/2018/04/27/线程（2）/">线程（2）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 小白拜拜拜<br>
  	  <span id="busuanzi_container_site_pv">
         本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span> 
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小白拜拜拜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小白拜拜拜">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="小白拜拜拜">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小白拜拜拜">
  
    <link rel="alternate" href="/atom.xml" title="小白拜拜拜" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小白拜拜拜</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网络（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/30/网络（2）/" class="article-date">
  <time datetime="2018-04-30T04:13:32.000Z" itemprop="datePublished">2018-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/30/网络（2）/">网络（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><h5 id="按照字节传输"><a href="#按照字节传输" class="headerlink" title="按照字节传输"></a>按照字节传输</h5><p>网络上的数据是一个字节一个字节串行传递的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"hello"</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">5</span>, ...)</span><br></pre></td></tr></table></figure></p>
<p>那么在信道中依次传输5个字节：<code>68 65 6c 6c 6f</code>。</p>
<h5 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h5><p>当观察到一个<code>unsigned int</code>型变量的内存,<code>unsigned int a = 0x12345678;</code><br>在内存中的排列为<code>78 56 34 12</code>，却不是<code>12 34 56 78</code>，原因是因为这是一种规定。<br>小端：低位字节在内存的低地址端，高位字节在内存的高地址端。主流系统都是小端的（<code>intel/amd</code>）<br>大端：低位字节在内存的高地址端，高位字节在内存的低地址端。</p>
<h5 id="网络传输字节序"><a href="#网络传输字节序" class="headerlink" title="网络传输字节序"></a>网络传输字节序</h5><p>网络传输的时候，惯例是按照大端传输的。即把接收到的第一个字节当做高位字节看待，这就要求发送端发送的第一个字节是高位字节，而在发送端发送数据时，发送的第一个字节应该是数值在内存中的起始地址对应的那个字节（即高位字节存放在低地址），将小端转换为大端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itob_32be</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bytes[<span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    bytes[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    bytes[<span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    bytes[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h4><h5 id="默认分配端口号"><a href="#默认分配端口号" class="headerlink" title="默认分配端口号"></a>默认分配端口号</h5><p>发送方<code>Socket</code>可以不显式的指定端口号：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UdpSocket sock;</span><br><span class="line">sock.open(); <span class="comment">//不带地址</span></span><br><span class="line">sock.SendTo(); <span class="comment">//发送数据</span></span><br></pre></td></tr></table></figure></p>
<p><code>SendTo</code>函数被调用时，<code>OS</code>发现这个<code>Socket</code>还没有分配端口号，于是立即为其自动分配一个端口号，然后进行发送，接收方必须指定端口号的，发送方自动分配的端口号有一个区间，一般在<code>10000</code>以上。可以通过以下方式查看：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_SockAddr local;</span><br><span class="line">sock.GetLocalAddr(local);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port = local.GetPort();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"local port: %d \n"</span>, port);</span><br><span class="line"><span class="comment">//在发送数据时，才会自动分配端口</span></span><br></pre></td></tr></table></figure></p>
<h5 id="端口的占用"><a href="#端口的占用" class="headerlink" title="端口的占用"></a>端口的占用</h5><p>当一个<code>Socket</code>使用了某个端口，那么直到这个<code>Socket</code>被关闭，这个端口都处于被占用的状态。如果还想创建一个<code>Socket</code>，并且使用相同的端口，则创建失败。<code>sock.open()</code>返回-1。所以将端口号设置为可重用的。<code>sock.open</code>第二个参数即是能否重用的选项（内部间接调用了<code>SetOpt_ReuseAddr</code>这个函数）。一般要设置为<code>true</code>，因为有时候程序会意外关闭，即时重新启动当操作系统还没有释放这个端口时，会出现错误。</p>
<h5 id="多个发送方，一个接收方"><a href="#多个发送方，一个接收方" class="headerlink" title="多个发送方，一个接收方"></a>多个发送方，一个接收方</h5><p>接收方可以区分一个消息是谁发送的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">OS_SockAddr peer;</span><br><span class="line"><span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br></pre></td></tr></table></figure></p>
<p><code>RecvFrom</code>只是从“接受缓冲区”里取出一个数据包，这个数据包本身是带有源地址的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> peer_ip = peer.GetIp_str();</span><br><span class="line"><span class="keyword">int</span> peer_port = peer.GetPort();</span><br></pre></td></tr></table></figure></p>
<h5 id="阻塞与超时"><a href="#阻塞与超时" class="headerlink" title="阻塞与超时"></a>阻塞与超时</h5><h6 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h6><p>接收方<code>sock.RecvFrom</code>：</p>
<ol>
<li>如果<code>RecvBuf</code>中有数据，则函数立即返回。</li>
<li>如果没有数据，则函数会一直等待，知道有数据时才取出数据，这个等待行为就是“阻塞”方式，可以设置最大等待时间，超过后如果仍然没有数据，函数返回-1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.SetOpt_RecvTimeOut(<span class="number">3000</span>) <span class="comment">//超过3s仍无数据，则RecvFrom返回-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h6><p>不管有没有数据，函数都立即返回，如果有数据，则返回值<code>&gt;0</code>，如果没有数据，则返回值为<code>-1</code>。此时，需要程序定时的去调用<code>RecvFrom</code>函数去查看有没有数据，这种设计模式叫做“轮询”。</p>
<h4 id="双工通讯"><a href="#双工通讯" class="headerlink" title="双工通讯"></a>双工通讯</h4><p><strong>单工</strong>：单向通信，A只能发信号，B只能接收信号，通信是单向的。（广播、电视）<br><strong>半双工</strong>： 双向通信但是不能同时进行，A能发信号给B，B也能发信号给A，但这两个过程不能同时进行。（要么上行（上传），要么下行（下载），比如对讲机）<br><strong>全双工</strong>：双向通信互不影响，A给B发信号的同时，B也可以给A发信号。（上行下行可同时进行，手机、电话）<br><code>UDP</code>是双工的。可以使用多线程的方式实现全双工操作，一个线程负责读，另一个线程负责写。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        OS_UdpSocket sock;</span><br><span class="line">        sock.Open();</span><br><span class="line">        <span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            sock.SendTo(buf, len, peer);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.Close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recv</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        OS_UdpSocket sock;</span><br><span class="line">        sock.Open(OS_SockAddr(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>), ture);</span><br><span class="line">        OS_SockAddr peer;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buf[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.Close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>协议，<code>protocal</code>，协议就是规定，是通信双方事先协商好的规则。它规定了数据的格式。没有协议，就无法实现数据的传输（对方读不懂）。<br>当要传递一个整数<code>0x12345678</code>给对方时，可以有多种方式。</p>
<ol>
<li>大端，按字节，<code>12 34 56 78</code>。</li>
<li>小端，按字节，<code>78 56 34 12</code>。</li>
<li>文本，十六进制， “<code>12345678</code>“（共八个字节）。</li>
<li>文本, 十进制，”<code>305419896</code>“（共九个字节）。<br>双方协商好按格式1进行传输，这便是协议。</li>
</ol>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>通过<code>UDP</code>传输，A发送B一个文件，协议如下：</p>
<ol>
<li>把文件分块传输，每块最大1024个字节。</li>
<li>数据包格式，前16字节表示指令<br> 01 开始传送 02 数据包 FF 结束传送</li>
</ol>
<p>主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open();</span><br><span class="line">File *fp = fopen(<span class="string">"123.tar"</span>, <span class="string">"rb"</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_SockAddr local;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"please input enter: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">getchar();</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">16</span>, peer);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = fread(buf + <span class="number">16</span>, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">    sock.SendTo(buf, n + <span class="number">16</span>, peer);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"send data packet, count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">sock.SendTo(buf, <span class="number">16</span>, peer);</span><br><span class="line">sock.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open(local, <span class="literal">true</span>);</span><br><span class="line">OS_SockAddr peer;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">1024</span> + <span class="number">16</span>];</span><br><span class="line">FILE* fp = fopen(<span class="string">"456.tar"</span>, <span class="string">"wb"</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">1024</span> + <span class="number">16</span>; peer);</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0x01</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection start"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0xFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection end"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(buf + <span class="number">16</span>, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"receive packet, count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="强化协议，减少丢包不怕丢包"><a href="#强化协议，减少丢包不怕丢包" class="headerlink" title="强化协议，减少丢包不怕丢包"></a>强化协议，减少丢包不怕丢包</h5><ol>
<li>A控制发送节奏，不要太快。使用线程的<code>sleep</code>函数。</li>
<li>确定应答模式，接收到应答后才发下一个包。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/30/网络（2）/" data-id="cjk4w3h8h000xnwqwxr7px7dr" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/网络（1）/" class="article-date">
  <time datetime="2018-04-27T14:21:22.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/网络（1）/">网络（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h4><h5 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h5><ol>
<li>主机： <code>Host</code>,包含台式机、笔记本、手机等设备。</li>
<li>网络： <code>Internet</code></li>
<li>网络介质：<code>Media</code>：网线，光纤，无线网域网<code>wifi</code>，移动<code>3G</code>网络。</li>
<li>数据：<code>Data</code>，一串字节。</li>
</ol>
<h5 id="网络通讯观测"><a href="#网络通讯观测" class="headerlink" title="网络通讯观测"></a>网络通讯观测</h5><p><code>wireshark</code>，“抓包”工具，抓，<code>capture</code>。包，<code>packet</code>,数据包。</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p><code>Internet protocol Address</code>，网络协议地址，用于标识网络上的一台主机。<br>通常采用4字节表示，称为<code>IPv4</code>。用字符串表示时，采用10进制，以点号分开：<br><code>&quot;192.168.1.1&quot;</code>（家庭路由器地址）、<code>&quot;123.57.248.214&quot;</code>,用16进制表示<code>C0 A8 01 01</code>、<code>7B 39 F8 D6</code>。</p>
<h5 id="ping：检测连通"><a href="#ping：检测连通" class="headerlink" title="ping：检测连通"></a>ping：检测连通</h5><p><code>windows/linux</code>下都有<code>ping</code>命令，它可以检查对方的主机是否能够连通。<code>ping 123.27.148.124</code>。如果能连通说明对方主机在线，否则请求超时有三种可能性：</p>
<ol>
<li>对方关机、离线</li>
<li>己方没有连网。</li>
<li>对方在线，但是屏蔽了<code>PING</code>服务。</li>
</ol>
<h5 id="查看自己的ip地址"><a href="#查看自己的ip地址" class="headerlink" title="查看自己的ip地址"></a>查看自己的ip地址</h5><p><code>windows: ipcofig linux: ifconfig</code></p>
<h4 id="Socket复用技术"><a href="#Socket复用技术" class="headerlink" title="Socket复用技术"></a>Socket复用技术</h4><h5 id="Socket概念"><a href="#Socket概念" class="headerlink" title="Socket概念"></a>Socket概念</h5><p>两台主机进行通讯，运行不同的程序，它们都在使用网络进行数据的传输。<br>为什么一台主机上的多个程序可以同时使用网络？引入<code>Socket</code>概念，原意为“插座”，形象的表示用一根线连接两个插座，即形成一个数据通道。每个插口可以用一个数字标识（<code>0~65535</code>），这个数字就称为端口（<code>Port</code>）。<br>两个程序要进行通讯，就要各自选择一个插口，然后连接起来。<br>程序1：在<code>192.168.1.100</code>上运行，使用端口<code>9001</code>。<br>程序2：在<code>192.168.1.101</code>上运行，使用端口<code>9002</code>。<br>连接上来，就形成了一个数据通道，它们俩之间可以交流数据了（只是逻辑上的通道）。</p>
<h5 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h5><p>在多个<code>socket</code>,每个<code>socket</code>上同时传输着不同的数据（视频、文件、网页下载等）。但是网线只有一根，字节是串行传输的，如何保证正确性？<br>可以采用<strong>封包</strong>的方法，将(<code>IP,Port</code>)放在包头。这种在一个信道中，交叉间隔的传输数据的方案，叫做“分时复用”。<code>Mux</code>，重复利用的意思。</p>
<ol>
<li>发送方：复用<code>Mux</code><br>将每个<code>Socket</code>上的数据，拆分成固定格式的小包，每个小包前面加上<code>IP/Port</code>，按照时间间隔，轮番发送到信道中。</li>
<li>接收方：解复用<code>Demux</code><br>从信道中接收小包，根据包头里的Port，将小包还原成原始数据，再分发给不同的<code>Socket</code>处理。</li>
</ol>
<h6 id="大包拆分成小包"><a href="#大包拆分成小包" class="headerlink" title="大包拆分成小包"></a>大包拆分成小包</h6><p>一边拆一边合。每个包的包头加上一些标识。分包的目的是各个Socket均匀占用网络。</p>
<h4 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h4><p><code>UDP</code>: <code>User Datagram Protocol</code>，用户数据报文协议。适用于局域网的主机间通信。两台主机上的程序，在知道了对方的<code>Socket</code>地址之后，就可以适用<code>UDP</code>传输数据。<br> 发送方：<code>UdpSocket sock; sock.sendTo(...)</code>。<br> 接收方：<code>UdpSocket sock; sock.RecvFrom(...)</code>。<br> 主要代码如下所示：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//发送方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)</span></span>; <span class="comment">//ip和端口号</span></span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.Open(local, <span class="literal">true</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"发送方: port 9000"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    sock.SendTo(buf, len, peer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="function">OS_SockAddr <span class="title">local</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9001</span>)</span></span>;</span><br><span class="line">OS_UdpSocket sock;</span><br><span class="line">sock.open(local, <span class="literal">true</span>);</span><br><span class="line"><span class="function">OS_SockAddr <span class="title">peer</span><span class="params">(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sock.RecvFrom(buf, <span class="number">128</span>, peer);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="number">0</span>; <span class="comment">//终止符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Got: "</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"bye"</span>, buf) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock.Close();</span><br></pre></td></tr></table></figure></p>
<h5 id="单机测试"><a href="#单机测试" class="headerlink" title="单机测试"></a>单机测试</h5><p>正常情况下，<code>Socket</code>编程的目的是为了将数据传送到另一台主机，因此需要两台主机才可以完成测试。例如<code>192.168.1.100 -&gt; 192.168.1.101</code>。当没有多主机环境时，可以使用单机测试，目标地址为<code>127.0.0.1</code>，表示本机。当指定发送目标为<code>127.0.0.1</code>时，发送的数据不经过网卡，直接在系统内回环送回。又称为<code>loopback</code>地址（回环地址）。<code>wireshark</code>无法监测<code>loopback</code>上的数据，因为根本没有通过网卡传送。</p>
<h5 id="多机测试"><a href="#多机测试" class="headerlink" title="多机测试"></a>多机测试</h5><p>局域网下的多机测试，可以在一台交换机上插上两台主机，构建一个局域网，然后两台主机间可以通讯。如果没有两台主机，可以使用虚拟机构建多机测试环境。保证在同一个网段，将<code>ip</code>地址与子网掩码做与运算（默认<code>255.255.255.0</code>），如果相同则在同一个网段。<code>wireshark</code>中有实现过滤和事后过滤。</p>
<h4 id="内部缓冲区"><a href="#内部缓冲区" class="headerlink" title="内部缓冲区"></a>内部缓冲区</h4><p><code>SendTo()</code>和<code>RecvFrom()</code>是由系统来完成的。那么</p>
<ol>
<li>在调用<code>SendTo</code>的时候，系统是立即发送的么？</li>
<li>在调用<code>RecvFrom</code>的时候，系统是接到命令再去接收的么？<br>在系统内部，每个<code>Socket</code>关联了两个缓冲区(<code>Buffer</code>)，一个用于发送，一个用于接收。缓冲区实际上就是一片内存，用于暂时存储数据。</li>
</ol>
<h5 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h5><ol>
<li><code>SendTo</code>把数据放在<code>SendBuf</code>里，通知<code>OS</code>来取。</li>
<li><code>OS</code>在适当的时候过来取数据，并发送到网络。<br>这意味着存入数据和发送数据存在着时间差，如果数据存入太快太多，发送缓冲区可能会满。</li>
</ol>
<h5 id="接收过程"><a href="#接收过程" class="headerlink" title="接收过程"></a>接收过程</h5><ol>
<li><code>OS</code>不停把从网络上接收的数据存储到<code>RecvBuf</code>里。</li>
<li><code>RecvFrom</code>从缓冲区中取数据。<br>这意味着不论是否去取数据，<code>OS</code>总是默默的把数据先接收下来存储好，<code>RecvFrom</code>是从<code>RecvBuf</code>里取走现成的数据。如果不及时取走，则缓冲区可能会满。</li>
</ol>
<p>发送和接收是一个异步过程，发送的时候，先把数据放入缓冲区中，然后由<code>OS</code>安排发送，接收的时候，由<code>OS</code>先接收下来存在缓冲区，而<code>RecvFrom</code>只是从缓冲区取走现成的数据。</p>
<h5 id="“缓冲区满”的处理"><a href="#“缓冲区满”的处理" class="headerlink" title="“缓冲区满”的处理"></a>“缓冲区满”的处理</h5><h6 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h6><ol>
<li>直到缓冲区有剩余空间（阻塞）。</li>
<li>新发送的数据没有存入缓冲区。</li>
</ol>
<h6 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h6><ol>
<li>新的数据不被接收。</li>
<li>删除缓冲区里的现有数据，存放新的数据<br>1和2都会引起丢包现象</li>
</ol>
<h6 id="设置发送-接收缓冲区的大小"><a href="#设置发送-接收缓冲区的大小" class="headerlink" title="设置发送/接收缓冲区的大小"></a>设置发送/接收缓冲区的大小</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setsocketopt(sock.hSock, SOL_SOCKET, <span class="comment">//opt即为option</span></span><br><span class="line">    SO_SENBUF, <span class="comment">//代表sendBuf，SO_RCVBUF代表recvBuf</span></span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;bufsize,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">int</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>设置成功与否由操作系统决定。</p>
<h6 id="丢包问题"><a href="#丢包问题" class="headerlink" title="丢包问题"></a>丢包问题</h6><p>一般情况下，设置缓冲区的大小并不能解决“丢包”问题。<br>要注意一下三个方面：</p>
<ol>
<li>发送是否均匀。</li>
<li>接收是否及时。</li>
<li>接收带宽是否超过实际传输带宽。发送数据量过大会丢包。视频包可能会出现。<br>另外，即使<code>HostA</code>和<code>HostB</code>处理的都没有问题，网络上的任意一个中间节点设备都有可能丢包。丢包问题对于<code>USP</code>来说是很常见的，再设计是就要考虑到这一点，再决定使用<code>UDP</code>的时候就应该允许丢包，要做的是尽量的减少丢包。</li>
</ol>
<h6 id="适合UDP传输的情况"><a href="#适合UDP传输的情况" class="headerlink" title="适合UDP传输的情况"></a>适合UDP传输的情况</h6><p>允许丢包的场合，比如每秒钟把设备的实时数据发送给管理主机，在管理主机的界面上显示。这种情况即使丢了一次包，也没有太大关系，下次会继续发送的。但是当传输压缩文件*.rar，如果丢了一个包，整个文件就损坏了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/网络（1）/" data-id="cjk4w3h8f000unwqwndu58pco" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/线程（3）/" class="article-date">
  <time datetime="2018-04-27T09:04:21.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/线程（3）/">线程（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="线程间的通信机制-信号量"><a href="#线程间的通信机制-信号量" class="headerlink" title="线程间的通信机制-信号量"></a>线程间的通信机制-信号量</h4><h5 id="引例（生产者消费者问题）"><a href="#引例（生产者消费者问题）" class="headerlink" title="引例（生产者消费者问题）"></a>引例（生产者消费者问题）</h5><p><code>Producer</code>: 生产者，每个几秒生成一个物品，并放入缓冲区中。<br><code>Consumer</code>: 消费者，一旦发现缓冲区里有物品即可取走。<br>一个读一个写。<br>如何能保证即时取走？</p>
<h6 id="轮询机制"><a href="#轮询机制" class="headerlink" title="轮询机制"></a>轮询机制</h6><p><code>Consumer</code>线程不知道何时有物品可以取，只是不停地去查询（比如每隔<code>50ms</code>查询一次，以便及时取走）轮询的间隔不能太大，否则缓冲区可能已经堆积如山了。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">OS_Mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">int</span> r = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"放入物品："</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            Msleep(r * <span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"取出物品："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            Msleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上段代码中，生产者和消费者之间是没有联系的，不能保证真正及时的取出来，查询不能太频繁（浪费<code>CPU</code>），不频繁的时候（缓存区满），难以把握，需要设计一个合理的轮询间隔。最好有一个通知机制：生产者把物品放进去之后，通知消费者，消费者接到通知后，再去取物品。这就出现了信号量机制。</p>
<h6 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h6><p>信号量：<code>Semaphore</code>,用于实现线程间的通知机制（和<code>Mutex</code>一样，是一个系统级对象）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS_Semaphore g_sem;</span><br><span class="line">第一个线程: Producer</span><br><span class="line">    g_sem.Post(); //通知</span><br><span class="line">第二个线程: Consumer</span><br><span class="line">    g_sem.Wait(); //等待通知</span><br></pre></td></tr></table></figure></p>
<p><code>osapi</code>库的源代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Semaphore::Init(<span class="keyword">int</span> initial_value)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = <span class="keyword">new</span> OS_Semaphore_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    m_Priv = priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;priv-&gt;hSem, <span class="number">1</span>, initial_value) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> OS_Semaphore::wait()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;priv-&gt;hsem) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OS_Semaphore::Post()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span>;</span><br><span class="line">    sem_post(&amp;priv-&gt;hSem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>信号量的值： <code>0, 1, 2, ..., N, ...</code><br>生产者可以一次放入多个物品，并将信号量的值增加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_sem.Post();//信号量的值加1</span><br><span class="line">g_sem.Wait();//信号量的值减1。如果信号量的值为0，则线程进入等待状态（阻塞），此时不占用cpu。</span><br></pre></td></tr></table></figure></p>
<p>使用信号量机制的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="function">OS_Semaphore <span class="title">g_sem</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//将初始信号量设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">int</span> r = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"放入物品："</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">            g_sem.Post();</span><br><span class="line">            Msleep(r * <span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            g_sem.Wait();</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"取出物品："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以根据实际情况，将信号量的值初始化为<code>0</code>或其他正数，一般情况信号量的初始值由你的实现应用中对应的那个量决定，比如，缓冲区中的物品数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OS_Semaphore g_sem(0);</span><br><span class="line">OS_Semaphore g_sem(10); //已经有了10个量</span><br></pre></td></tr></table></figure></p>
<h6 id="超时等待机制"><a href="#超时等待机制" class="headerlink" title="超时等待机制"></a>超时等待机制</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = g_sem.Wait(<span class="number">1000</span>); <span class="comment">//ms</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>) <span class="comment">//如果返回值不为0，表明已经超时</span></span><br><span class="line">&#123;<span class="comment">//超时处理&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>osapi</code>中超时处理的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Semaphore::Wait(<span class="keyword">int</span> ms)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Semaphore_Priv* priv = (OS_Semaphore_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    timeval tv_now;</span><br><span class="line">    gettimeofday(&amp;tv_now, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    timespec ts;</span><br><span class="line">    ts.tv_sec = tv_now.tv_sec;</span><br><span class="line">    ts.tv_nsec = tv_now.tv_usec * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ns = ts.tv_nsec + (ms % <span class="number">1000</span>)  * <span class="number">1000000</span>;</span><br><span class="line">    ts.tv_nsec = ns % <span class="number">1000000000</span>;</span><br><span class="line">    ts.tv_sec += ns / <span class="number">1000000000</span>;</span><br><span class="line">    ts.tv_sec += ms / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sem_timedwait(&amp;priv-&gt;hSem, &amp;ts) != <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/线程（3）/" data-id="cjk4w3h88000tnwqwsac5z86t" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/线程（2）/" class="article-date">
  <time datetime="2018-04-27T07:07:47.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/线程（2）/">线程（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h4><p>多个线程间可以共享数据：</p>
<ol>
<li>全局对象</li>
<li>堆对象（动态创建的数据）<br>全局对象和堆对象的生命期足够长。</li>
</ol>
<h4 id="数据的完整性"><a href="#数据的完整性" class="headerlink" title="数据的完整性"></a>数据的完整性</h4><p>当一个线程在写，另一个线程在读，由于线程的调度由操作系统进行切换，可能数据处理操作未完成就被切换，所以这时可能会出现问题。数据不完整的根本原因是线程运行时可能会在任意时刻、任意位置被切换。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>当多个线程同时访问一块内存，就有可能会出现数据不完整的问题。此时，需要一种机制来“同步”各个线程对它的访问。（所谓同步，是指协调、安排，使之步调一致）。这种机制就是“互斥锁”机制。在<code>C++`</code>里称为<code>Mutex</code>，<code>Java</code>里称为<code>Lock</code>。</p>
<h6 id="互斥锁的使用"><a href="#互斥锁的使用" class="headerlink" title="互斥锁的使用"></a>互斥锁的使用</h6><p>在访问共享数据之前，先获取锁，在访问完毕后再释放锁。在一个线程获取锁之后，另一个线程的<code>Lock</code>操作会一直等待（阻塞），直到该锁被释放（<code>unlocked</code>）。</p>
<h6 id="互斥锁的使用模式"><a href="#互斥锁的使用模式" class="headerlink" title="互斥锁的使用模式"></a>互斥锁的使用模式</h6><ol>
<li><p>在osapi创建全局对象或堆对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">char</span> g_data[<span class="number">128</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在线程中要访问<code>g_data</code>，必须先获取锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g_mutex.Lock(); <span class="comment">//此函数会阻塞，一直等待拥有锁</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) g_data[i] = i;</span><br><span class="line">g_mutex.Unlock(); <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在<code>osapi</code>中，Lock函数和Unlock函数的相关代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_Mutex::Lock()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Mutex_Priv* priv = (OS_Mutex_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_lock(&amp;priv-&gt;hMutex) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">01</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> OS_Mutex::Unlock()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Mutex_Priv* priv = (OS_Mutex_Priv*)m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;priv-&gt;hMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>锁机制是操作系统提供的资源，实际上是操作系统锁对象的封装。</p>
<h6 id="互斥锁的使用原则"><a href="#互斥锁的使用原则" class="headerlink" title="互斥锁的使用原则"></a>互斥锁的使用原则</h6><p>当一个线程占有锁时，应该尽快地完成对共享数据的访问。因为别的线程正在等待。一般策略是直接把数据拷贝一份然后再做处理（处理时间一般比拷贝时间更长）。<br>实例：提供一个<code>generator</code>类和一个<code>checker</code>类，<code>generator</code>将同一个值赋给<code>arr[16]</code>数组中的所有元素。<code>checker</code>检测<code>arr</code>数组中所有元素的值是否相等。不适用互斥锁时会出现数据完整性的问题，添加数据锁后代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = time;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checker</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] != arr[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"check fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，每次<code>generate</code>和<code>check</code>操作的时间为<code>80ms</code>，锁占用的时间也均为<code>80ms</code>，锁占用的时间较长，其他请求这个锁的线程需要等待，这样就违背了使用多线程提升效率的目的。<br>更改的方法是先将数据进行拷贝，再进行处理，在数据生成的时候，先将耗费<code>80ms</code>的生成数据存储在<code>copy</code>数组中，这个过程不需要再占用锁，然后将<code>copy</code>数组的内容复制到<code>arr</code>数组，在复制过程中需要占用锁，但是因为复制的时间很短，所以效率得到了提升，同时保证了数据的完整性。在校验过程中，可以先将<code>arr</code>数组中的值拷贝到<code>copy</code>数组中，这个过程占用锁，然后对<code>copy</code>数组的值进行校验，这个过程不需要再占用锁，这样就达到了优化的效果。优化后的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">OS_Mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                copy[i] = time;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="built_in">memcpy</span>(arr, copy, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">16</span>);</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checker</span> :</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_mutex.Lock();</span><br><span class="line">            <span class="built_in">memcpy</span>(copy, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">16</span>);</span><br><span class="line">            g_mutex.UnLock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(copy[i] != copy[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"check fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Msleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="可重入的函数（线程安全的函数）"><a href="#可重入的函数（线程安全的函数）" class="headerlink" title="可重入的函数（线程安全的函数）"></a>可重入的函数（线程安全的函数）</h4><p>可重入（reentrant）的函数，又称为线程安全（thread safe）的函数，是指一个函数，在多个线程里同时调用（并发调用）的时候，<strong>其功能仍然正常</strong>。在并发调用时功能出错的函数称为不可重入的函数（线程不安全）。<br>实例：线程的任务是不断的进行<code>1~n</code>的累加。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        num += i;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span> <span class="keyword">public</span> OS_Thread&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">virtaul <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = sum(n);</span><br><span class="line">            <span class="keyword">if</span>(res != <span class="number">5050</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实际上上一段代码是线程安全的，但如果将<code>sum</code>函数中的变量<code>num</code>设置为全局变量，则函数变为非线程安全的，因为全局变量在不同的线程之间是可以共享的。所以线程切换时可能会导致全局变量的值不是正确的，原有逻辑受到了影响。</p>
<h6 id="判断是否可重入："><a href="#判断是否可重入：" class="headerlink" title="判断是否可重入："></a>判断是否可重入：</h6><ol>
<li>在单线程的情况下，该函数表现正常，如果单线程出了问题，说明函数写错了。</li>
<li>在多线程并发调用此函数时，如果函数仍然表现正常，则说明该函数是可重入的。</li>
</ol>
<h6 id="很可能不可重入的情况："><a href="#很可能不可重入的情况：" class="headerlink" title="很可能不可重入的情况："></a>很可能不可重入的情况：</h6><ol>
<li>一个全局函数（写在类之外的函数），借助全局对象来实现，并且有写操作，那么就是不可重入的。</li>
<li>一个类的成员函数，它访问并修改了成员变量，那么一般情况下它就是不可重入的。</li>
</ol>
<h6 id="将不可重入转换成可重入的"><a href="#将不可重入转换成可重入的" class="headerlink" title="将不可重入转换成可重入的"></a>将不可重入转换成可重入的</h6><ol>
<li>不借助外部变量，尽量使用本函数内定义的局部变量来实现。或者在本函数动态创建对象，并在退出前销毁对象。没有外部依赖，不操作外部变量。</li>
<li>实在不行的话可以加上互斥锁控制。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/线程（2）/" data-id="cjk4w3h86000qnwqw6lqacdxh" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/26/线程（1）/" class="article-date">
  <time datetime="2018-04-26T13:09:31.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/26/线程（1）/">线程（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>main</code>函数是主线程，即使没有使用其他的线程，这条主线程也一直存在，主线程退出所有的线程整个程序就都退出了。使用<code>Thread</code>技术创建的线程，它们用于运行并发的任务。普通函数的调用是无法实现并行的任务的。</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>假如只有一个<code>CPU</code>，所有的线程共享这个<code>CPU</code>。</p>
<ol>
<li>每个线程都要自觉的让出<code>CPU</code>，使得其他线程也有机会被运行。可以使用<code>Sleep</code>实现。</li>
<li>操作系统会把时间分割成很细的小片（时间片），让每个线程都会有机会运行几毫秒，轮流运行。（宏观上感觉是线程在并行执行）。</li>
<li>使用<code>Sleep</code>函数让一个线程处于休眠状态，当一个线程休眠时，<code>CPU</code>会供其他线程使用。操作系统会统一进行调度，决定哪个线程被执行。</li>
</ol>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>当<code>Task1.exe</code>被加载到内存中运行时，运行的实例成为一个进程。（可以在任务管理器中查看），<code>Task1.exe</code>称为程序文件，它可以同时被运行多次，每运行一次，一个新的进程就被创建。一个进程中可以创建多个线程，其中至少有一个主线程。由操作系统负责安排调度；决定哪一个线程被运行。不同操作系统遵循同一个原则，尽可能让所有的线程都有机会运行。</p>
<h4 id="调度方法-时间片法："><a href="#调度方法-时间片法：" class="headerlink" title="调度方法 时间片法："></a>调度方法 时间片法：</h4><p>把<code>cpu</code>时间划分为均等的时间片，总体上看各个线程是被轮流运行的。线程切换过程如下：</p>
<ol>
<li>把当前的线程切到后台，进入队列等待。队列可以称为候选队列，表示里面的线程都希望自己被立刻执行。</li>
<li>从队列中取得一个正在排队的线程并运行这个线程。</li>
<li><code>5ms</code>后再次进行切换（时间片为<code>5ms</code>）</li>
</ol>
<p>需要知道</p>
<ol>
<li>使用<code>Sleep</code>函数，可以主动让自己的线程提前让出<code>CPU</code>。</li>
<li><code>Sleep</code>时间到的时候，线程并不是立即执行的，而是进入了候选队列。如果设定了N毫秒，实际间隔的时间会大于N。一般会支持到毫秒量级。</li>
<li>由操作系统决定如何在候选队列里挑选下一个线程。</li>
</ol>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>某些操作系统可能支持线程的优先级，<code>Priority</code>。允许我们再创建线程的时候，指定一下线程的优先级。如果优先级较高，则该线程在运行的时候拥有较高的机会被调度。但是可能不可靠，不是所有的系统都支持，并且可能无法定量。</p>
<h4 id="线程创建与启动"><a href="#线程创建与启动" class="headerlink" title="线程创建与启动"></a>线程创建与启动</h4><p>例如使用<code>osapi</code>库，定义一个Task类，继承于<code>OS_Thread</code>，重写线程主函数<code>Routine()</code>（这是一个虚函数），使用时<code>MyTask task; task.Run();</code>。在多数系统中，线程的创建和启动是一个连续的动作。线程属于系统级资源，可以在“资源管理器”中查看每个进程的线程数。创建线程是操作系统进行的，不能直接调用<code>Routine</code>函数。调用<code>Run</code>函数时，相当于对<code>OS</code>说“请创建一个线程，入口函数为<code>Routine()</code>”，OS则根据程序员的要求，创建一个线程实体来运行，线程的主函数就是<code>Routine()</code>。主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">OS_Thread_Proc_Linux</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OS_Thread* thrd = (OS_Thread*) param;</span><br><span class="line">    thrd-&gt;Routine();  <span class="comment">//Routine函数声明virtual int Routine() = 0;</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> OS_Thread::Run()</span><br><span class="line">&#123;</span><br><span class="line">    OS_Thread_Priv* priv = <span class="keyword">new</span> OS_Thread_Priv;</span><br><span class="line">    <span class="keyword">if</span>(!priv) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    m_Priv = priv;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;priv-&gt;hThread, <span class="literal">NULL</span>, OS_Thread_Proc_Linux, <span class="keyword">this</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>Run</code>函数后，主要通过调用<code>pthread_create</code>函数创建线程，实际上线程主函数是<code>OS_Thread_Proc_Linux</code>，然后在这个函数中由调用了程序员重载的纯虚函数<code>Routine</code>。</p>
<h6 id="两种语境"><a href="#两种语境" class="headerlink" title="两种语境"></a>两种语境</h6><ol>
<li><code>OS_Thread:</code>它是一个<code>C++</code>类/对象，封装了线程相关数据和操作。</li>
<li>线程实体：由操作系统创建的实体，通常说的线程指的是线程实体，是一个运行时的概念。<h6 id="线程是有限的资源"><a href="#线程是有限的资源" class="headerlink" title="线程是有限的资源"></a>线程是有限的资源</h6>线程是系统级资源，线程的切换和调度也是有成本的，所以一个进程中的最大线程数是有限制的，一般为几千到几万。在工程实践中，一般线程数最多为几十个。</li>
</ol>
<h4 id="线程的停止和回收"><a href="#线程的停止和回收" class="headerlink" title="线程的停止和回收"></a>线程的停止和回收</h4><h6 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h6><p>在<code>osapi</code>中，当<code>return</code>语句被执行时，表示该线程正常退出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"do something \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//线程主函数退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>return</code>语句被执行、<code>Routine()</code>函数返回，线程退出。</p>
<h6 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h6><p>当主线程（主程序）退出的时候，所有的线程都会被立即终止，即使有线程正在运行。这种终止时不正常的，有可能会造成数据的不完整。<br>例如主函数中添加了<code>getchar</code>函数，当没有<code>getchar</code>函数时，主线程会一直执行，执行完毕后立即退出，所以其他线程也可能会异常终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Buddhist task1;</span><br><span class="line">    task1.Run(); <span class="comment">//线程1</span></span><br><span class="line">    Confucian task2;</span><br><span class="line">    task2.Run(); <span class="comment">//线程2</span></span><br><span class="line">    getchar(); <span class="comment">//输入回车主线程终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="线程的回收"><a href="#线程的回收" class="headerlink" title="线程的回收"></a>线程的回收</h6><p>使用<code>OS_Thread::Join(&amp;task);</code>等待线程的退出，函数实现如下，实际上是对pthread_join函数进行了封装。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OS_Thread::Join(OS_Thread* thrd)</span><br><span class="line">&#123;</span><br><span class="line">    OS_Thread_Priv* priv = (OS_Thread_Priv*) thrd-&gt;m_Priv;</span><br><span class="line">    <span class="keyword">if</span>(priv)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_join(priv-&gt;hThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> priv;</span><br><span class="line">        thrd-&gt;m_Priv = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Join</code>函数的作用：</p>
<ol>
<li>等待目标线程的退出，如果目标线程尚未退出，则会一直等待，直到其退出为止。</li>
<li>回收这个线程的相关系统资源（线程的个数是受限的）。</li>
</ol>
<p><code>Join</code>的调用：当一个线程A要退出时，由另一个线程调用来回收线程A。需要注意的是：<code>Join</code>不能回收自己。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Join(<span class="keyword">this</span>); <span class="comment">//出错的，不能自己join自己</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以由主线程或者任何一个其他线程执行<code>Join</code>。<code>Join</code>的位置：不能只看字面上的位置，而是要从运行的角度来看待问题，例如如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buddhist</span>:</span> <span class="keyword">public</span> OS_Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_quitfalg = <span class="literal">false</span>;</span><br><span class="line">        Run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_quitfalg = <span class="literal">true</span>;</span><br><span class="line">        Join(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_quitfalg;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Routine</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; !m_quitfalg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ma mi ma mi hong..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            OS_Thread::Sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"善后工作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，<code>Join</code>函数位于创建线程类的<code>stop</code>函数中，并且将<code>this</code>作为参数，但实际上这种写法是正确的，因为<code>stop</code>函数是在主函数即主线程中调用，虽然代码中使用<code>Join(this)</code>，但实际上并不是自己等待自己。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/26/线程（1）/" data-id="cjk4w3h84000onwqwuok0j070" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Building-C-Projects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/Building-C-Projects/" class="article-date">
  <time datetime="2018-04-25T13:59:56.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/Building-C-Projects/">Building C Projects</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要对构建C项目的过程进行描述，主要参考这篇博客(<a href="http://nethack4.org/blog/building-c.html" target="_blank" rel="noopener">http://nethack4.org/blog/building-c.html</a>)<br></p>
<ol>
<li>配置（Configuration）</li>
<li>标准目录检测（Standard directory detection）</li>
<li>源文件依赖计算（Source file dependency calculation）</li>
<li>头文件定位（Head file location）</li>
<li>头文件预编译（Header precomplition）</li>
<li>预处理（Preprocessing）</li>
<li>编译和汇编（Compilation and assembly）</li>
<li>目标文件依赖计算（Object file dependency calculation）</li>
<li>链接（linking）</li>
<li>安装（Installation）</li>
<li>资源链接（Resource linking）</li>
<li>包生成（Package generation）</li>
<li>动态链接（Dynamic linking）<br>主要过程如上所示，实际上C不一定要按照上述步骤构建。如果按部就班的讲解很难描述清楚，因为有些步骤是接下来一些步骤的准备，很容易让人迷惑，所以从第6部开始慢慢延伸。</li>
</ol>
<h4 id="6：-Preprocessing"><a href="#6：-Preprocessing" class="headerlink" title="6： Preprocessing"></a>6： Preprocessing</h4><p>使用下面的c程序作为示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Hello, world!\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们首先要关注第一行<code>#include&lt;stdio.h&gt;</code>，一个常见的误解是这行程序与一些库有关系，它将fputs的定义与库中的程序联系在一起。实际上这行代码只是告诉编译器fputs和stdout所拥有的类型，等同于下面代码（省略了很多不相关的代码）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, FILE *)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Hello, world!\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上与链接没有关系，stdio.h只是一些类型、函数、变量和宏定义的声明列表。C标准对于编译器如何实现这些定义没有任何限制，但实际上，类似stdio.h这样的头文件几乎都由轻量扩展的C程序实现。在这个例子中FILE是一个不完全的类型，extern意味着只是一个声明，不一定包含函数或变量的定义。<br><br>预处理同时会移除源文件中的注释。如今，预处理阶段经常与编译阶段同时进行，但是预处理阶段也是可以单独进行的，使用-E指令进行预处理操作，预处理后的文件后缀为.i。</p>
<h4 id="5：Header-precomplition"><a href="#5：Header-precomplition" class="headerlink" title="5：Header precomplition"></a>5：Header precomplition</h4><p>不同的源码文件可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译，为了节省时间，并且如果头文件的声明有错误，每个包含该头文件的程序都会出现相同错误，无论是否与这个错误相关联，编译器会在编译源码之前，先编译头文件。这保证头文件只需要编译一次，不过并不是头文件的所有内容都会被预编译。例如用来声明宏的#define指令，就不会被预编译。</p>
<h4 id="4：Header-file-location"><a href="#4：Header-file-location" class="headerlink" title="4：Header file location"></a>4：Header file location</h4><p>为了能够包含头文件，必须能够在文件系统中找到，大多数预处理使用的方法都很简单，可以使用一个硬编码的目录列表，用户可以将其添加到目录中，预处理时会按照顺序进行扫描，知道找到正在查找的文件。<br><br>当项目较大时，也可以通过扫描经过适当命名的头文件资源树，然后通过比较路径（根据目录结构采用最接近的匹配头文件）来计算出哪个头文件是预期的。当使用分层构建时，项目的不同部分必须放置在不同的目录中，采用这种方法使较为明智的。</p>
<h4 id="3：Source-file-dependency-calculation"><a href="#3：Source-file-dependency-calculation" class="headerlink" title="3：Source file dependency calculation"></a>3：Source file dependency calculation</h4><p>对于大型项目，源码文件之间往往存在着依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。<br><br>（1）只有在B文件编译完成后，才开始编译A文件。<br><br>（2）当B文件发生变化时，A文件才能被重新编译。<br><br>如今依赖自动化的方法主要通过预处理器对包含的每个头文件进行报告（大多数可以直接生成makefile片段），这会引发chicken-and-egg问题（只有通过编译才能计算出依赖，只有获取依赖才能顺利编译）。标准的方法是首先在没有依赖的情况下进行构建，这满足了第一点要求，但是第二点并不满足。<br>编译顺序保存在makefile文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须先运行的原因。在确定依赖关系的同时，编译器也确定了编译时会用到哪些头文件。</p>
<h6 id="2：Standard-directory-detection"><a href="#2：Standard-directory-detection" class="headerlink" title="2：Standard directory detection"></a>2：Standard directory detection</h6><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。<br><br>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p>
<h6 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1: Configuration"></a>1: Configuration</h6><p>在编译器开始工作之前，需要知道当前系统的环境，比如标准库在哪里，软件安装在哪里，需要安装哪些组件等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的代码。这个确定编译参数的步骤，就叫做配置（Configuration）。<br><br>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。<br><br>configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/www --with-mysql</span><br></pre></td></tr></table></figure></p>
<p>上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。</p>
<h4 id="7-Compilation-and-assembly"><a href="#7-Compilation-and-assembly" class="headerlink" title="7: Compilation and assembly"></a>7: Compilation and assembly</h4><p>预处理阶段输出的是轻微扩展的C代码，目标文件（链接器的输入）则是轻微修改的机器码，与处理器实际运行的机器代码的区别在于它充满了与链接器相关的指令以及与处理器相关的指令。<br><br>有两种方法可以将c代码转换成机器码。一种方法是直接进行转换，另外一种是通过汇编代码，即通过编译和汇编两个过程，汇编代码可以通过C代码执行-S指令获得，也可以通过对目标文件进行反汇编获得。上述示例的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;t.c&quot;</span><br><span class="line">.section    .rodata             Contents of section .rodata:</span><br><span class="line">.LC0:</span><br><span class="line">.string &quot;Hello, world!\n&quot;       Hello, world!..</span><br><span class="line">.text                           Disassembly of section .text:</span><br><span class="line">.globl  main</span><br><span class="line">.type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq   %rbp                    push   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp              mov    %rsp,%rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">movq    stdout(%rip), %rax      mov    0x0(%rip),%rax</span><br><span class="line">movq    %rax, %rcx              mov    %rax,%rcx</span><br><span class="line">movl    $14, %edx               mov    $0xe,%edx</span><br><span class="line">movl    $1, %esi                mov    $0x1,%esi</span><br><span class="line">movl    $.LC0, %edi             mov    $0x0,%edi</span><br><span class="line">call    fwrite                  callq  22 &lt;main+0x22&gt;</span><br><span class="line">movl    $0, %eax                mov    $0x0,%eax</span><br><span class="line">popq    %rbp                    pop    %rbp</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.size   main, .-main</span><br><span class="line">.ident  &quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot;</span><br><span class="line">.section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码包括一些与链接器相关的信息，有些在机器码中是不存在的。汇编代码中有很多段来告诉链接器不同数据存储的位置，main函数从.text开始，.rodate代表只读，.cfi_代表生成栈展开信息，例如可以通过objdump -d test.o获得反汇编代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format elf64-x86-64          </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:                  </span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:                        </span><br><span class="line">   0:   55                      push   %rbp      </span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp  </span><br><span class="line">   4:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax</span><br><span class="line">   b:   48 89 c1                mov    %rax,%rcx</span><br><span class="line">   e:   ba 0e 00 00 00          mov    $0xe,%edx</span><br><span class="line">  13:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  18:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  1d:   e8 00 00 00 00          callq  22 &lt;main+0x22&gt;</span><br><span class="line">  22:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  27:   5d                      pop    %rbp</span><br><span class="line">  28:   c3                      retq</span><br></pre></td></tr></table></figure></p>
<p>使用objdump -x命令可以生成symbol table，可以对符号表中的值进行定位。使用-S命令进行编译，使用-c进行汇编。</p>
<h4 id="8-Object-file-dependency-calculation"><a href="#8-Object-file-dependency-calculation" class="headerlink" title="8: Object file dependency calculation"></a>8: Object file dependency calculation</h4><p>一旦生成了目标文件，下一步要考虑的是如何将这些目标文件组合在一起生成可执行文件。为了生成可执行文件，需要获得满足依赖关系的目标文件和相关库的列表，在这些目标文件中出现的任何未定义的符号都需要被其他的目标文件所定义，同时也需要提供开始运行的入口点。<br><br>对于每个主函数都有一个可执行文件，可以通过递归的查找未定义符号所依赖的库或目标文件。</p>
<h4 id="9-Linking"><a href="#9-Linking" class="headerlink" title="9: Linking"></a>9: Linking</h4><p>一旦了解需要组合哪些目标文件来生成可执行文件，下一步通过链接器生成可执行文件，观察第七步生成的汇编代码，会发现其中引用了stdout函数和fwrite函数。也就是说程序要正常运行，还需要stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。<br><br>编译器下一步工作是把外部函数的代码（通常后缀名为.lib和.a的文件），添加到可执行文件中，其中涉及到内存地址的定位等。这种通过拷贝，将外部函数添加到可执行文件的方式叫做静态链接。后文还会提到动态链接。<br>make命令的作用是从第五步到这一步结束。</p>
<h4 id="10-Installation"><a href="#10-Installation" class="headerlink" title="10: Installation"></a>10: Installation</h4><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。表面上这个过程很简单，就是将可执行文件（连带相关的数据文件）拷贝过去即可。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就成为“安装”。</p>
<h4 id="11-Resource-Linking"><a href="#11-Resource-Linking" class="headerlink" title="11: Resource Linking"></a>11: Resource Linking</h4><p>资源链接通常和安装过程同时进行，正常的方法是手动编写构建规则以执行相关步骤。在windows上，VS在链接后立即执行资源链接。</p>
<h4 id="12-Package-generation"><a href="#12-Package-generation" class="headerlink" title="12: Package generation"></a>12: Package generation</h4><p>到这里，源码编译的过程就基本完成了。但事实上，如果只有源码可以交给用户是很不友好的。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，能够将上一步生成的可执行文件做成可以分发的安装包。所以编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关数据文件）以某种目录结构保存成压缩文件包交给用户。</p>
<h4 id="13-Dynamic-Linking"><a href="#13-Dynamic-Linking" class="headerlink" title="13: Dynamic Linking"></a>13: Dynamic Linking</h4><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。<br><br>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。<br><br>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/Building-C-Projects/" data-id="cjk4w3h4z0000nwqwjx3asbtw" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试复习（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/面试复习（2）/" class="article-date">
  <time datetime="2018-04-24T16:56:04.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/面试复习（2）/">面试复习（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-两个栈模拟一个队列（模板代码）"><a href="#1-两个栈模拟一个队列（模板代码）" class="headerlink" title="1.两个栈模拟一个队列（模板代码）"></a>1.两个栈模拟一个队列（模板代码）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    if(stack2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        while(!stack1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    if(stack2.empty())</span><br><span class="line">        throw new exception(&quot;queue is empty&quot;);</span><br><span class="line">    tmp = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-二进制中1的个数"><a href="#2-二进制中1的个数" class="headerlink" title="2.二进制中1的个数"></a>2.二进制中1的个数</h4><p>最重要的公式：将一个整数和它减一的结果做位与运算，相当于把最右边的1变成了0。所以伪代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n &amp; (n - 1);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-数值的整数次方"><a href="#3-数值的整数次方" class="headerlink" title="3.数值的整数次方"></a>3.数值的整数次方</h4><p>实现函数double Power(double base, int exponent)，需要注意的有以下几点：<br><br>1.当指数为负数时，先求绝对值，计算后求倒数。<br><br>2.当底数为0且指数为负数时，会出现对0求倒数，可以通过返回值，全局代码或异常来处理错误。<br><br>3.0的0次方时没有意义的，所以要考虑这个边界值。<br><br>4.判断底数是否为0时，不能直接写base = 0，因为在计算机内表示小数时会有误差，判断两个小数是否相等时，只能判断它们的差得绝对值是否在很小的范围内。<br><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">bool g_InvalidInput = false;</span><br><span class="line">bool equal(double num1, double num2)</span><br><span class="line">&#123;</span><br><span class="line">    if(num1 - num2 &lt; 0.0000001 &amp;&amp; num1 - num2 &gt; -0.0000001)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double PowerWithUnsignedExponent(double base, unsigned int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    if(exponent == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return base;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(exponent == 0)</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1);</span><br><span class="line">    result *= result;</span><br><span class="line">    if(exponent % 2 == 1)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">double Power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    g_InvalidInput = false;</span><br><span class="line">    int absExponent = exponent;</span><br><span class="line">    if(equal(base, 0.0) &amp;&amp; exponent &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = true;</span><br><span class="line">        return 0.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned int absExponent = unsigned int(exponent);</span><br><span class="line">    if(exponent &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        absExponent = (unsigned int)()-exponent);</span><br><span class="line">    &#125;</span><br><span class="line">    double res = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">    if(exponent &lt; 0)</span><br><span class="line">        res = 1.0 / res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-在O-1-时间内删除链表节点"><a href="#4-在O-1-时间内删除链表节点" class="headerlink" title="4. 在O(1)时间内删除链表节点"></a>4. 在O(1)时间内删除链表节点</h4><p>通常方法是从头查找，这是因为我们需要得到将被删除的节点的前一个节点，实际上可以得到删除节点的下一个节点，将下一个节点的内容复制到需要删除的节&gt;点，再将下一个节点删除即可。如果删除的节点位于链表的尾部则需要继续从头开始删除。时间复杂度为[(n-1)O(1) + O(n)]/n，结果还是O(1)。相关代码如下&gt;：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void DeleteHead(ListNode** pListHead, ListNode* pToBeDeleted)</span><br><span class="line">&#123;</span><br><span class="line">    if(!pListHead || !pToBeDeleted)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">    if(pToBeDeleted-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* tmp = pToBeDeleted-&gt;next;</span><br><span class="line">        pToBeDeleted-&gt;value = tmp-&gt;val;</span><br><span class="line">        pToBeDeleted-&gt;next = tmp-&gt;next;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = NULL;</span><br><span class="line">        *pListHead = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* tmp = *pListHead;</span><br><span class="line">        while(tmp-&gt;next != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = NULL;</span><br><span class="line">        delete pToBeDeleted;</span><br><span class="line">        pToBeDeleted = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-linux-c多线程编程"><a href="#5-linux-c多线程编程" class="headerlink" title="5. linux c多线程编程"></a>5. linux c多线程编程</h4><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>进程是资源分配的最小单位，线程是程序执行的最小单位。<br><br>进程是程序的一个实例，拥有自己独立的各种段（数据段，代码段等等），每次创建一个进程需要从操作系统分配资源，这个过程会消耗一定的时间，在linux下C语言创建一个进程使用fork()函数。<br><br>线程是一个轻量级的进程，除了自己少数的资源，不需要其他的资源，且一个进程可以创建多个线程，这些线程共享进程的资源，创建线程的时间比创建进程要少的多（几十分之一），从函数角度使用clone()创建。<br><br>使用线程处理文件I/O或者socket处理都是非常有优势的，讲一个大任务分解成若干个小任务，每个线程处理一个任务，线程之间切换不需要花费很多时间，而且线程之间的数据交换很方便，可以共享存储区。</p>
<h6 id="C语言使用多线程的函数"><a href="#C语言使用多线程的函数" class="headerlink" title="C语言使用多线程的函数"></a>C语言使用多线程的函数</h6><p>pthread_t在头文件/usr/include/bits/pthreadtypes.h中定义：<br>typedef unsigned long int pthread_t;<br>它是一个线程的标识符。</p>
<h6 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(thread, attr, start_routine, arg);</span><br><span class="line">extern int pthread_create __P ((pthread_t __thread,</span><br><span class="line">                              __const pthread_attr_t *__attr,</span><br><span class="line">                              void (__start_routine) (void ),</span><br><span class="line">                              void *__arg));</span><br></pre></td></tr></table></figure>
<p><code>pthread_create</code>创建一个可执行的进程。<br><br><code>thread</code>是一个指向线程标识符的指针。<br><br><code>attr</code>是一个不透明的属性对象，可以对线程属性进行设置也可以使用默认值<code>NULL</code>。<br><br><code>start_routine</code>是线程运行函数的起始地址，一旦线程被创建就会执行函数。<br><br><code>arg</code>是运行函数的参数。它必须通过把引用作为指针强制转换为<code>void</code>类型进行传递。如果没有传递函数，可以使用<code>NULL</code>。<br><br>创建线程成功时，函数返回0，若返回值不为0则说明创建线程失败。<br>创建线程成功后，新创建的线程则运行参数3和参数4确定的函数，原来的线程则继续运行下一行代码。</p>
<h6 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_exit(status);</span><br><span class="line">extern void pthread_exit P((void *__retval))__attribute((noreturn));</span><br></pre></td></tr></table></figure>
<p><code>pthread_exit</code>用于显式的推出一个线程。唯一的参数是函数的返回代码。<br><br>通常情况下，<code>pthread_exit</code>函数在线程完成工作后无需继续存在时被调用。如果main是在它所创建的线程结束之前结束，并通过pthread_exit()退出，那么其他线程将继续执行。否则，它们将在main()讲述时自动被终止。</p>
<h6 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_join (threadid, status)</span><br><span class="line">extern int pthread_join __P ((pthread_t __th, void **__thread_return));</span><br></pre></td></tr></table></figure>
<p>第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，可以用来存储被等待线程的返回值，这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。<br>最后要说明的是，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join的线程则返回错误代码<code>ESRCH</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/面试复习（2）/" data-id="cjk4w3h8u0014nwqwqocvgkek" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/复习/">复习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LLVM学习（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/22/LLVM学习（3）/" class="article-date">
  <time datetime="2018-04-21T16:37:24.000Z" itemprop="datePublished">2018-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/22/LLVM学习（3）/">LLVM学习（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇通过简单的HelloWorld演示了在LLVM中编写Pass的基本方法，本文将介绍一些其他的pass实例,创建以及修改pass文件以及build llvm等内容不再重复。<br>首先在LLVM中，程序的基本单位是模块。函数是模块的基本组成单位，一个模块由一个或多个函数组成。Basic Block又是函数的基本组成单位，所以一个Function由一个或多个Basic block组成。指令是Basic Block的基本组成单位，一个Basic Block由一个或多个指令组成。<br><br>Module—&gt;Function—&gt;Basic Block—&gt;instruction</p>
<h5 id="利用pass在函数中遍历Basic-Block"><a href="#利用pass在函数中遍历Basic-Block" class="headerlink" title="利用pass在函数中遍历Basic Block"></a>利用pass在函数中遍历Basic Block</h5><p>本文中直接在HelloWorld.cpp中进行修改，内容修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/ADT/Statistic.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Function.h&quot;</span><br><span class="line">#include &quot;llvm/Pass.h&quot;</span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">#define DEBUG_TYPE &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, &quot;Counts number of functions greeted&quot;);</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  struct HelloWorld : public FunctionPass &#123;</span><br><span class="line">    static char ID; // Pass identification, replacement for typeid</span><br><span class="line">    HelloWorld() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">      errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">      errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">      for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">      &#123;   </span><br><span class="line">        errs() &lt;&lt; &quot;BasicBlock name = &quot; &lt;&lt; bb-&gt;getName() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">        for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            outs() &lt;&lt; &quot; &quot; &lt;&lt; *i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char HelloWorld::ID = 0;</span><br><span class="line">static RegisterPass&lt;HelloWorld&gt; X(&quot;helloWorld&quot;, &quot;Hello World Pass&quot;);</span><br></pre></td></tr></table></figure></p>
<p>代码首先打印每个函数的名称，接下来使用迭代器对每个函数中的Basic Block进行遍历，并且输出每个Basic Block的名称和大小。然后对每个Basic Block中的指令进行遍历。输出每条具体指令。接下来创建测试文件cul.cpp，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mul(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; add(1, 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mul(5, 6) &lt;&lt; endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来使用以下命令执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ cul.cpp -O0 -S -emit-llvm -o cul.ll</span><br><span class="line">opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld cul.ll</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 3</span><br><span class="line"></span><br><span class="line">   call void @_ZNSt8ios_base4InitC1Ev(%&quot;class.std::ios_base::Init&quot;* @_ZStL8__ioinit)</span><br><span class="line">   %1 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%&quot;class.std::ios_base::Init&quot;*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%&quot;class.std::ios_base::Init&quot;, %&quot;class.std::ios_base::Init&quot;* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #3</span><br><span class="line">   ret void</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 8</span><br><span class="line"></span><br><span class="line">   %3 = alloca i32, align 4</span><br><span class="line">   %4 = alloca i32, align 4</span><br><span class="line">   store i32 %0, i32* %3, align 4</span><br><span class="line">   store i32 %1, i32* %4, align 4</span><br><span class="line">   %5 = load i32, i32* %3, align 4</span><br><span class="line">   %6 = load i32, i32* %4, align 4</span><br><span class="line">   %7 = add nsw i32 %5, %6</span><br><span class="line">   ret i32 %7</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 8</span><br><span class="line"></span><br><span class="line">   %3 = alloca i32, align 4</span><br><span class="line">   %4 = alloca i32, align 4</span><br><span class="line">   store i32 %0, i32* %3, align 4</span><br><span class="line">   store i32 %1, i32* %4, align 4</span><br><span class="line">   %5 = load i32, i32* %3, align 4</span><br><span class="line">   %6 = load i32, i32* %4, align 4</span><br><span class="line">   %7 = mul nsw i32 %5, %6</span><br><span class="line">   ret i32 %7</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 9</span><br><span class="line"></span><br><span class="line">   %1 = alloca i32, align 4</span><br><span class="line">   store i32 0, i32* %1, align 4</span><br><span class="line">   %2 = call i32 @_Z3addii(i32 1, i32 2)</span><br><span class="line">   %3 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEi(%&quot;class.std::basic_ostream&quot;* @_ZSt4cout, i32 %2)</span><br><span class="line">   %4 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEPFRSoS_E(%&quot;class.std::basic_ostream&quot;* %3, %&quot;class.std::basic_ostream&quot;* (%&quot;class.std::basic_ostream&quot;*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)</span><br><span class="line">   %5 = call i32 @_Z3mulii(i32 5, i32 6)</span><br><span class="line">   %6 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEi(%&quot;class.std::basic_ostream&quot;* @_ZSt4cout, i32 %5)</span><br><span class="line">   %7 = call dereferenceable(272) %&quot;class.std::basic_ostream&quot;* @_ZNSolsEPFRSoS_E(%&quot;class.std::basic_ostream&quot;* %6, %&quot;class.std::basic_ostream&quot;* (%&quot;class.std::basic_ostream&quot;*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)</span><br><span class="line">   ret i32 0</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock name =</span><br><span class="line">BasicBlock size = 2</span><br><span class="line"></span><br><span class="line">   call void @__cxx_global_var_init()</span><br><span class="line">   ret void</span><br></pre></td></tr></table></figure>
<p>由结果可知，共执行了五个函数，每个函数有一个基本块（Basic Block），每个基本块的size即为基本块中指令的数量。</p>
<h5 id="利用pass对程序中的操作码进行计数"><a href="#利用pass对程序中的操作码进行计数" class="headerlink" title="利用pass对程序中的操作码进行计数"></a>利用pass对程序中的操作码进行计数</h5><p>代码中主要使用map对每个函数中出现的操作码进行统计，对每一条指令可以使用getOpcodeName获取操作码。主要代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">  std::map&lt;std::string, int&gt; m;</span><br><span class="line">  std::map&lt;std::string, int&gt;::iterator iter;</span><br><span class="line">  errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">  errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        std::string tmpName = i-&gt;getOpcodeName();</span><br><span class="line">        if(m.find(tmpName) == m.end())</span><br><span class="line">        &#123;   </span><br><span class="line">            m[tmpName] = 1;</span><br><span class="line">        &#125;   </span><br><span class="line">        else</span><br><span class="line">            m[tmpName]++;</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line">  for(iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; &quot;\n&quot;;</span><br><span class="line">  &#125;   </span><br><span class="line">  errs() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">  m.clear();</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用同样命令执行后结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock size = 3</span><br><span class="line">call 2</span><br><span class="line">ret 1</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">add 1</span><br><span class="line">alloca 2</span><br><span class="line">load 2</span><br><span class="line">ret 1</span><br><span class="line">store 2</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">alloca 2</span><br><span class="line">load 2</span><br><span class="line">mul 1</span><br><span class="line">ret 1</span><br><span class="line">store 2</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock size = 9</span><br><span class="line">alloca 1</span><br><span class="line">call 6</span><br><span class="line">ret 1</span><br><span class="line">store 1</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock size = 2</span><br><span class="line">call 1</span><br><span class="line">ret 1</span><br></pre></td></tr></table></figure></p>
<p>通过结果可知，每个基本块的大小与所有操作码数量之和是相同的。</p>
<h5 id="Def-Use-and-Use-Def"><a href="#Def-Use-and-Use-Def" class="headerlink" title="Def-Use and Use-Def"></a>Def-Use and Use-Def</h5><p>Def-Use实现的功能是找出所有使用了某一个def（或称value）的instruction。Use-Def实现的功能是针对某一个instruction输出其所使用的所有operands（操作数）.</p>
<blockquote>
<p><strong>Def-Use:</strong> Frequently, we might have an instance of the Value Class and we want to determine which Users use the Value. The list of all Users of a particular Value is called a def-use chain.<br>let’s say we have a Function* named F to a particular function foo. Finding all of the instructions that use foo is as simple as iterating over the def-use chain of F:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function *F = ...;    </span><br><span class="line">for (User *U : F-&gt;users()) &#123;  </span><br><span class="line">  if (Instruction *Inst = dyn_cast&lt;Instruction&gt;(U)) &#123;  </span><br><span class="line">    errs() &lt;&lt; &quot;F is used in instruction:\n&quot;;  </span><br><span class="line">    errs() &lt;&lt; *Inst &lt;&lt; &quot;\n&quot;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中使用到了动态类型转换dyn_cast&lt;&gt;,用来检测操作数是否是特定的类型，如果是的话则返回指针（不能使用引用），否则的话就返回空指针，dyn_cast与c++中的dynamic_cast类似，与c++不同的是dynamic_cast只能在拥有虚函数表的类中使用：通常dyn_cast运算符在if语句或其他控制语句中使用，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (auto *AI = dyn_cast&lt;AllocationInst&gt;(Val)) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种形式的语句将isa&lt;&gt;和cast&lt;&gt;结合在一起，较为方便。isa&lt;&gt;类似于java的”instanceof”, cast&lt;&gt;将一个指针或引用从基类转换为派生类。最终代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">  errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">  errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        Instruction* inst = dyn_cast&lt;Instruction&gt;(i);</span><br><span class="line">        if(inst-&gt;getOpcode() == Instruction::Add || inst-&gt;getOpcode() == Instruction::Mul)</span><br><span class="line">        &#123;   </span><br><span class="line">            for(User *U: inst-&gt;users())</span><br><span class="line">            &#123;   </span><br><span class="line">                if(Instruction *Inst = dyn_cast&lt;Instruction&gt;(U))</span><br><span class="line">                &#123;   </span><br><span class="line">                    outs() &lt;&lt; &quot;Opcode &quot; &lt;&lt; inst-&gt;getOpcodeName() &lt;&lt; &quot; used in ::&quot;;</span><br><span class="line">                    outs() &lt;&lt; *Inst &lt;&lt; &quot;\n&quot;;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用之前的测试c++代码，输出结果如下,由上面的.ll程序可知，首先在函数中使用add和mul指令，然后在下一行ret指令中使用到了运算生成的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze84k9sdnqv3f0fuhpwz LLVMCODE]# opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld cul.ll</span><br><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock size = 3</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">Opcode add used in ::  ret i32 %7</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">Opcode mul used in ::  ret i32 %7</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock size = 9</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock size = 2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Use-Def</strong> Alternatively, it’s common to have an instance of the User Class and need to know what Values are used by it. The list of all Values used by a User is known as a use-def chain. Instances of class Instruction are common User s, so we might want to iterate over all of the values that a particular instruction uses (that is, the operands of the particular Instruction):</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instruction *pi = ...;  </span><br><span class="line"></span><br><span class="line">for (Use &amp;U : pi-&gt;operands()) &#123;  </span><br><span class="line">  Value *v = U.get();  </span><br><span class="line">  // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">  errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">  errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">  for(Function::iterator bb = F.begin(); bb != F.end(); bb++)</span><br><span class="line">  &#123;   </span><br><span class="line">    errs() &lt;&lt; &quot;BasicBlock size = &quot; &lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(); i != bb-&gt;end(); i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        Instruction* inst = dyn_cast&lt;Instruction&gt;(i);</span><br><span class="line">        if(inst-&gt;getOpcode() == Instruction::Add || inst-&gt;getOpcode() == Instruction::Mul)</span><br><span class="line">        &#123;   </span><br><span class="line">            for(Use &amp;U: inst-&gt;operands())</span><br><span class="line">            &#123;   </span><br><span class="line">                Value *v = U.get();</span><br><span class="line">                outs() &lt;&lt; *v &lt;&lt; &quot;\n&quot;;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用之前的测试c++代码，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze84k9sdnqv3f0fuhpwz LLVMCODE]# opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld cul.ll</span><br><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Function name: __cxx_global_var_init</span><br><span class="line">BasicBlock size = 3</span><br><span class="line">Function name: _Z3addii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">  %5 = load i32, i32* %3, align 4</span><br><span class="line">  %6 = load i32, i32* %4, align 4</span><br><span class="line">Function name: _Z3mulii</span><br><span class="line">BasicBlock size = 8</span><br><span class="line">  %5 = load i32, i32* %3, align 4</span><br><span class="line">  %6 = load i32, i32* %4, align 4</span><br><span class="line">Function name: main</span><br><span class="line">BasicBlock size = 9</span><br><span class="line">Function name: _GLOBAL__sub_I_cul.cpp</span><br><span class="line">BasicBlock size = 2</span><br></pre></td></tr></table></figure></p>
<p>由上输出结果可知，分别输出了add指令和mul指令的两个操作数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/22/LLVM学习（3）/" data-id="cjk4w3h7c000cnwqwzvkps3rk" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM/">LLVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LLVM学习（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/LLVM学习（2）/" class="article-date">
  <time datetime="2018-04-20T03:15:52.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/LLVM学习（2）/">LLVM学习（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LLVM的pass框架是LLVM系统的重要部分。LLVM的优化和转换工作就是由多个pass来一起完成的的。类似流水线操作一样，每个pass完成特定的优化工作。所有的pass大致可以分成两类：分析和转换分析类的pass以提供信息为主，转换类的会修改中间代码。</p>
<p>假如LLVM的安装目录为/root/CL/llvm，那么首先在路径/root/CL/llvm/lib/Transforms中创建一个子文件夹，例如名字为HelloWorld。然后在此文件夹下创建三个文件，可以从其他文件夹复制过来。然后需要修改上层目录（Transforms）中的CMakeLists.txt：需要修改三次文件名，修改为HelloWorld，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if( NOT LLVM_REQUIRES_RTTI )</span><br><span class="line">  if( NOT LLVM_REQUIRES_EH )</span><br><span class="line">    set(LLVM_EXPORTED_SYMBOL_FILE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/HelloWorld.exports)</span><br><span class="line">  endif()</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if(WIN32 OR CYGWIN)</span><br><span class="line">  set(LLVM_LINK_COMPONENTS Core Support)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">add_llvm_loadable_module( LLVMHelloWorld</span><br><span class="line">  HelloWorld.cpp</span><br><span class="line"></span><br><span class="line">  DEPENDS</span><br><span class="line">  intrinsics_gen</span><br><span class="line">  PLUGIN_TOOL</span><br><span class="line">  opt</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>上述build script中的如下部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_loadable_module( LLVMHelloWorld</span><br><span class="line">  HelloWorld.cpp  </span><br><span class="line"></span><br><span class="line">  PLUGIN_TOOL  </span><br><span class="line">  opt  </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这种写法指定当前目录中的HelloWorld.cpp文件编译并链接到共享对象../lib/LLVMHelloWorld.so中，该选项可以通过opt选项工具进行动态加载。如果操作系统使用.so之外的后缀（windows或mac）,则将使用相应的扩展名。</p>
<p>接下来是pass文件中的具体内容，这个pass文件实际上就是一个.cpp文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/IR/Function.h&quot;  </span><br><span class="line">#include &quot;llvm/Pass.h&quot;  </span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;  </span><br><span class="line"></span><br><span class="line">using namespace llvm;  </span><br><span class="line"></span><br><span class="line">#define DEBUG_TYPE &quot;hello&quot;  </span><br><span class="line"></span><br><span class="line">namespace &#123;  </span><br><span class="line">  struct HelloWorld : public FunctionPass &#123;  </span><br><span class="line">    static char ID; // Pass identification, replacement for typeid  </span><br><span class="line">    HelloWorld() : FunctionPass(ID) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;  </span><br><span class="line">        errs() &lt;&lt; &quot;HelloWorld: &quot;;  </span><br><span class="line">        errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">char MyHello::ID = 0;  </span><br><span class="line">static RegisterPass&lt;HelloWorld&gt; X(&quot;helloWorld&quot;, &quot;Hello World Pass&quot;);</span><br></pre></td></tr></table></figure></p>
<p>代码1~3行首先需要引入用到的LLVM头文件，之后DEBUG_TYPE是LLVM用来统计该pass被呼叫的次数或者使用DEBUG输出出错信息时使用的。引用llvm命名空间，这不是好的习惯，但是较为方便。<br><br>使用匿名namespace，避免与export中的symbol冲突，其中HelloWorld继承FunctionPass，代表HelloWorld Pass的输入时以Function为单位。以下代码是重中之重,LLVM会以Function为单位作为参数传递，将每个Function的名称打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool runOnFunction(Function &amp;F) override &#123;  </span><br><span class="line">    errs() &lt;&lt; &quot;HelloWorld: &quot;;  </span><br><span class="line">    errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的Function pass独立的执行每一个函数。实现一个Function pass通常很简单，Function pass可能会重载三个虚方法（例如runOnFunction）。所有这些方法如果修改程序则返回true，否则返回false。</p>
<p>接下来需要build LLVM，进入/root/CL/build目录中，直接make即可。在自己的环境下不到一分钟就可以完成。出现下图时，表示已经make完成，这时在/root/CL/build/lib中出现LLVMHelloWorld.so文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[ 95%] Built target llvm-opt-report</span><br><span class="line">[ 96%] Built target llvm-pdbutil</span><br><span class="line">[ 96%] Built target RcTableGen</span><br><span class="line">[ 96%] Built target llvm-rc</span><br><span class="line">[ 96%] Built target llvm-readobj</span><br><span class="line">[ 96%] Built target llvm-readelf</span><br><span class="line">[ 96%] Built target llvm-rtdyld</span><br><span class="line">[ 96%] Built target llvm-size</span><br><span class="line">[ 96%] Built target llvm-special-case-list-fuzzer</span><br><span class="line">[ 96%] Built target llvm-split</span><br><span class="line">[ 96%] Built target llvm-stress</span><br><span class="line">[ 96%] Built target llvm-strings</span><br><span class="line">[ 96%] Built target llvm-symbolizer</span><br><span class="line">[ 98%] Built target llvm-xray</span><br><span class="line">[ 98%] Built target obj2yaml</span><br><span class="line">[ 98%] Built target opt</span><br><span class="line">[ 98%] Built target sancov</span><br><span class="line">[ 98%] Built target sanstats</span><br><span class="line">[ 98%] Built target verify-uselistorder</span><br><span class="line">[100%] Built target yaml2obj</span><br><span class="line">[100%] Built target SecondLib</span><br><span class="line">[100%] Built target PipSqueak</span><br><span class="line">[100%] Built target DynamicLibraryLib</span><br><span class="line">[100%] Built target gtest_main</span><br></pre></td></tr></table></figure></p>
<p>然后可以在期望位置建立新的测试文件，例如cul.cpp内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sub(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mul(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int divi(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用clang++ cul.cpp -O3 -S -emit-llvm -o cul.ll命令进行编译，生成.ll文件。然后执行pass，方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld  cul.ll</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下,由此可见pass的作用是逐个的在提示符”Hello”后输出程序中函数的名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze84k9sdnqv3f0fuhpwz LLVMCODE]# opt -load ../CL/build/lib/LLVMHelloWorld.so -helloWorld  cul.ll</span><br><span class="line">WARNING: You&apos;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&apos; option.</span><br><span class="line"></span><br><span class="line">Hello: _Z3addii</span><br><span class="line">Hello: _Z3subii</span><br><span class="line">Hello: _Z3mulii</span><br><span class="line">Hello: _Z4diviii</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/LLVM学习（2）/" data-id="cjk4w3h6c0006nwqwrexg44rd" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM/">LLVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/18/面试复习/" class="article-date">
  <time datetime="2018-04-18T03:40:05.000Z" itemprop="datePublished">2018-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/18/面试复习/">面试复习（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="1-指针数组和数组指针-读法与顺序相反"><a href="#1-指针数组和数组指针-读法与顺序相反" class="headerlink" title="1.指针数组和数组指针(读法与顺序相反)"></a>1.指针数组和数组指针(读法与顺序相反)</h6><p>int (*p) [n]; 数组指针，首先是一个指针然后这个指针指向整型数组。<br><br>int *p[n]; []优先级更高，首先是一个数组，int* 说明了这个数组的元素是int指针。</p>
<h6 id="2-常量指针和指针常量-读法与顺序相同"><a href="#2-常量指针和指针常量-读法与顺序相同" class="headerlink" title="2.常量指针和指针常量(读法与顺序相同)"></a>2.常量指针和指针常量(读法与顺序相同)</h6><p>int const* p; 常量指针，首先是一个指针这个指针指向常量。<br><br>int * const p; 指针常量，首先是一个常量，并且用指针修饰，指针不能更改。</p>
<h6 id="3-字符串转换为整数"><a href="#3-字符串转换为整数" class="headerlink" title="3.字符串转换为整数"></a>3.字符串转换为整数</h6><p>输入的指针不能为空，对正负值进行判断，对输入的字符进行判断是否包含非数值字符，以及溢出处理。除了完成基本的功能外，还会关注是否考虑了边界条件、特殊输入(Null指针，空字符串等)以及错误处理。</p>
<h6 id="4-sizeof-Class"><a href="#4-sizeof-Class" class="headerlink" title="4.sizeof(Class)"></a>4.sizeof(Class)</h6><p>定义空类型，里面没有任何成员变量和成员函数，对该类似求sizeof()，得到的结果是1。空类型的实例不包含任何信息，本来应该是0，但是当声明该类型的实例时，必须在内存中占有一定的空间，否则无法使用。具体由编译器决定。加上构造和析构函数也是一样，只需要知道函数的地址即可。函数的地址只与类型有关而与实例无关。如果把析构函数标记为虚函数，会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，32位上4个字节，64位上8个字节。</p>
<h6 id="5-拷贝构造函数"><a href="#5-拷贝构造函数" class="headerlink" title="5.拷贝构造函数"></a>5.拷贝构造函数</h6><p>拷贝构造函数不允许传值，如果允许就会在拷贝构造函数内调用拷贝构造函数，就会形成永无休止的递归调用从而导致栈溢出。所以是不允许的，标准形式为A（const A&amp; other）。</p>
<h6 id="6-赋值运算符函数"><a href="#6-赋值运算符函数" class="headerlink" title="6.赋值运算符函数"></a>6.赋值运算符函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; operator=(const CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    if(this == str)</span><br><span class="line">    &#123;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    delete []m_pData;</span><br><span class="line">    m_pData = NULL;</span><br><span class="line">    m_pData = new char[strlen(str.m_pData) + 1];</span><br><span class="line">    strcpy(m_pData, str.m_pData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h6><ol>
<li>是否把返回值类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。只有返回引用才允许连续赋值。否则如果函数的返回值是void，str1=str2=str3无法通过编译。</li>
<li>是否把传入的参数类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次拷贝构造函数。声明为引用可以避免消耗，提升效率。在赋值运算符函数内不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。</li>
<li>是否释放实例自身已有的内存，忘记在新内存前释放自己已有的空间程序将出现内存泄露。</li>
<li>是否判断传入参数和当前实例是否相同，如果相同则直接返回，如果事先不判断就进行赋值，那么在释放实例自身的内存时会出现严重的问题；当*this和传入参数相同时，一旦释放了自身内存，传入参数的内存同时被释放，再也找不到需要赋值的内容了。</li>
</ol>
<h6 id="高级做法："><a href="#高级做法：" class="headerlink" title="高级做法："></a>高级做法：</h6><p>再分配内存前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，m_pData将是一个空指针，这样会引起程序崩溃。违背了异常安全性的原则。在赋值运算符函数中实现异常安全性，有两种方法。一是先用new分配新内容在用delete进行释放已有内容。这样只在分配内容成功后再释放原来的内容，当分配内存失败时我们可以确保实例不会被修改。更好的方法是先创建临时实例，再交换临时实例和原来的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; operator=(const CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    if(this != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        CMyString strTemp(str);</span><br><span class="line">        char* pTemp = strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData = m_pData;</span><br><span class="line">        m_pData = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>strTemp是一个局部变量，但程序运行到if外面时出了变量的作用域，就会自动调用strTemp的析构函数，把strTemp.m_pData所指向的区域释放掉。相当于自动调用析构函数释放实例的内存。在CMyString的构造函数里用new分配内存。如果由于内存不足抛出bad_alloc等异常，我们还没有修改原来的实例状态，所以保证了异常安全性。</p>
<h6 id="7-vector、数组、指针"><a href="#7-vector、数组、指针" class="headerlink" title="7.vector、数组、指针"></a>7.vector、数组、指针</h6><p>为了解决数组空间效率不高的问题，人们又设计实现了多种动态数组，比如c++的stl中的vector。为了避免浪费，我们先为数组开辟较小的空间，然后往数组中添加数据。当数组的数目超过数组的容量时，我们再重新分配一块更大的空间(stl中的vector每次扩充容量时，新的容量都是前一次的两倍)，把之前的数据复制到新的数组中，再把之前的内存释放，这样就能减少内存的浪费。每次扩充数组的容量都有大量的额外操作，这对时间性能有负面影响，因此使用动态数组要尽量减少改变数组容量大小的操作。在c++中当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。</p>
<h6 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8.字符串"></a>8.字符串</h6><p>sizeof(string)，string的实现在不同的库中可能有不同，但是同一个库中相同点是，无论string中放多长的字符串，它的sizeof都是固定的，字符串的所占空间是从堆中动态分配的，与sizeof无关。自己的机器上是32。c/c++中每个字符串都以字符’\0’作为结尾，这样可以方便的找到字符串的最后尾部。但由于这个特点，每个字符串中都有一个额外字符开销，可能会造成越界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[10];</span><br><span class="line">strcpy(str, &quot;0123456789&quot;);</span><br></pre></td></tr></table></figure></p>
<p>由于\0的原因，要正确的复制该字符串，至少需要一个长度为11个字节的数组。<br><br>为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但使用常量内存初始化数组，情况会有所不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;hello world&quot;;</span><br><span class="line">char str2[] = &quot;hello world&quot;;</span><br><span class="line">char* str3 = &quot;hello world&quot;;</span><br><span class="line">char* str4 = &quot;hello world&quot;;</span><br><span class="line">string str5 = &quot;hello world&quot;;</span><br><span class="line">string str6 = &quot;hello world&quot;;</span><br></pre></td></tr></table></figure></p>
<p>str1和str2两个字符串数组，会为它们分配两个长度为12个字节的空间，并把“hello world”分别复制进去。这是两个初始地址不同的数组。str3和str4是两个指针，我们无须为它们分配内存来存储字符串中的内容，而只需要把它们指向”hello world”在内存中的地址即可。常量字符串在内存中只有一个拷贝，因此str3和str4指向同一个地址。str5与str6也是相同的，并且与str3公用内存地址。<br><br>合并两个数组(包括字符串)时，如果从前往后复制每个数字(或字符)需要重复移动数字(或字符)多次，那么可以考虑从后向前复制，这样就能减少移动的次数，从而提高效率。(替换空格题目)</p>
<h6 id="9-链表"><a href="#9-链表" class="headerlink" title="9.链表"></a>9.链表</h6><p>特别注意向链表添加节点函数的第一个参数是指向指针的指针。当我们向空链表插入一个节点时，新插入的节点就是链表的头指针。由于此时会改动头指针，因此必须把pHead参数设为指针的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void AddToTail(ListNode** pHead, int value)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* pNew = new ListNode();</span><br><span class="line">    pNew-&gt;m_nValue = value;</span><br><span class="line">    pNew-&gt;m_pNext = NULL;</span><br><span class="line">    if(*pHead == NULL)</span><br><span class="line">        *pHead = pNew;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* temp = *pHead;</span><br><span class="line">        while(temp-&gt;m_pnext != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;m_pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;m_pnext = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="10-红黑树"><a href="#10-红黑树" class="headerlink" title="10.红黑树"></a>10.红黑树</h6><p>红黑树是把树中的节点定义为红黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。在c++的stl中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。</p>
<h6 id="11-c-成员变量的初始化"><a href="#11-c-成员变量的初始化" class="headerlink" title="11.c++成员变量的初始化"></a>11.c++成员变量的初始化</h6><p>c++中成员变量的初始化顺序只与它们在类中声明的顺序有关，而与在初始化列表中的顺序无关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int n1;</span><br><span class="line">    int n2;</span><br><span class="line">public:</span><br><span class="line">    A(): n2(0), n1(n2 + 2)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>n1先于n2被声明，因此n1也会在n2之前被初始化，所以先会用n2+2去初始化n1.由于n2这个时候还没有被初始化，因此它的值是随机的。</p>
<h6 id="12-查找和排序"><a href="#12-查找和排序" class="headerlink" title="12.查找和排序"></a>12.查找和排序</h6><p>要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，可以尝试使用二分查找算法。哈希表最主要的优点是能够在O(1)时间查找某一个元素，是效率最高的查找方式。但缺点是需要额外的空间来实现哈希表。能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面比较不同排序算法的优缺点。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//快速排序代码</span><br><span class="line">int partition(int data[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(data == NULL || start &lt; 0 || end &lt; 0)</span><br><span class="line">        throw new std::exception(&quot;Invalid Parameters&quot;);</span><br><span class="line">    int small = start - 1;</span><br><span class="line">    for(int i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(data[i] &lt; data[end])</span><br><span class="line">        &#123;</span><br><span class="line">            small++;</span><br><span class="line">            if(small != i)</span><br><span class="line">            &#123;</span><br><span class="line">                int temp = data[small];</span><br><span class="line">                data[small] = data[i];</span><br><span class="line">                data[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    int temp = data[small];</span><br><span class="line">    data[small] = data[end];</span><br><span class="line">    data[end] = temp;</span><br><span class="line"></span><br><span class="line">    return small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(int data[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    int idx = partition(data, start, end);</span><br><span class="line">    if(idx - 1 &gt; start)</span><br><span class="line">        quickSort(data, start, idx - 1);</span><br><span class="line">    if(end &gt; idx + 1)</span><br><span class="line">        quickSort(data, idx + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在子数组data[start…end]中，partition维护了四个区域。data[start…small]区间内的值都小于等于data[end],data[small+1…i]的区间都大于data[end]，data[i+1,end-1]区间内的所有值没有限制。data[end]为每一轮选取的数字。</p>
<table>
<thead>
<tr>
<th style="text-align:center">&lt;=x</th>
<th style="text-align:center">&gt;x</th>
<th style="text-align:center">无限制</th>
<th style="text-align:center">选取值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">start—&gt;small</td>
<td style="text-align:center">small+1—&gt;i</td>
<td style="text-align:center">i+1—&gt;end-1</td>
<td style="text-align:center">end</td>
</tr>
</tbody>
</table>
<h6 id="13-C-标准库和std命名空间"><a href="#13-C-标准库和std命名空间" class="headerlink" title="13.C++标准库和std命名空间"></a>13.C++标准库和std命名空间</h6><p>C++是在C语言的基础上进行开发的，早期的C++并不完善，不支持命名空间也没有自己的编译器，而是将C++代码翻译成C代码，再通过C编译器完成编译。这个时候的C++仍然使用C语言的库，stdio.h、stdlib.h、string.h等头文件依然有效；此外C++也开发了一些新的库，增加了自己的头文件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostream.h fstream.h complex.h</span><br></pre></td></tr></table></figure></p>
<p>和C语言一样，C++头文件仍然以.h为后缀，它们所包含的类、函数、宏等都是全局范围的。后来C++引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是std。std是standard的缩写，即为“标准命名空间”。但是这时已经有很多用老式C++开发的程序，它们的代码中并没有使用命名空间，直接修改原来的库会带来很严重的后果。所以提出了新的想法，保留原来的库和头文件，它们可以在C++中继续使用，然后再将原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间std下，这就成为了新版C++标准库，这样共存在了两份功能相似的库。<br><br>为了避免头文件重命名，新版的C++库也对头文件的命名进行了调整，去掉了后缀.h，所以老式C++的iostream.h变为iostream，fstream.h变为了fstream。而对于原来的C语言头文件，也采用同样的方法，但在每个名字前要添加一个c字母，如stdio.h变为cstdio，stdlib.h变为cstdlib。<br>需要注意的是旧的C++头文件是官方所反对使用的，已明确提出不再支持，但是旧的C头文件仍然可以使用，以保持兼容性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/18/面试复习/" data-id="cjk4w3h8q0012nwqwua7r8uc6" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/复习/">复习</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HSI/">HSI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLVM/">LLVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/effective-c/">effective c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/false-sharing/">false sharing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复习/">复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HSI/" style="font-size: 10px;">HSI</a> <a href="/tags/LLVM/" style="font-size: 15px;">LLVM</a> <a href="/tags/effective-c/" style="font-size: 20px;">effective c++</a> <a href="/tags/false-sharing/" style="font-size: 10px;">false sharing</a> <a href="/tags/复习/" style="font-size: 15px;">复习</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/网络/" style="font-size: 20px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/28/I-O模型/">I/O模型</a>
          </li>
        
          <li>
            <a href="/2018/07/27/backtrace-and-coredump/">backtrace and coredump</a>
          </li>
        
          <li>
            <a href="/2018/07/09/网络（4）/">网络（4）</a>
          </li>
        
          <li>
            <a href="/2018/05/30/effective-c-（4）/">effective c++（4）</a>
          </li>
        
          <li>
            <a href="/2018/05/29/effective-c-（3）/">effective c++（3）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 小白拜拜拜<br>
  	  <span id="busuanzi_container_site_pv">
         本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span> 
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>